"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var _require = require("util"),
  promisify = _require.promisify;
var _require2 = require("tough-cookie"),
  Cookie = _require2.Cookie,
  CookieJar = _require2.CookieJar;
var HttpOptions = require("./http-options");
var HttpResponse = require("./http-response");
var _require3 = require("./http-client-utils"),
  retryWithStrategies = _require3.retryWithStrategies;
var HttpBackend = require("./http-backends/http-backend");
var typedefs = require("./typedefs");
var sleep = promisify(setTimeout);

// private methods
var _setClientCookies = Symbol("_setClientCookies");
var _getClientCookies = Symbol("_getClientCookies");

// private methods
var PRIVATE = Symbol("PRIVATE");

/**
 * Supports submitting and managing in-progress HTTP requests. Features of the
 * client include retrying failed requests, and timing request duration.
 */
var HttpClient = /*#__PURE__*/function () {
  function HttpClient() {
    _classCallCheck(this, HttpClient);
    this[PRIVATE] = {
      cookieJar: new CookieJar()
    };
  }

  /**
   * Sets the default global options that will be applied to all requests that go through
   * the client.
   *
   * @param {typedefs.ClientRequestOptions} options Global options to add to all requests.
   */
  _createClass(HttpClient, [{
    key: "setGlobalOptions",
    value: function setGlobalOptions(options) {
      this[PRIVATE].options = options;
    }

    /**
     * Retrieves the default global options that will be applied to all requests that go through
     * the client.
     *
     * @returns {typedefs.ClientRequestOptions} Global options to add to all requests.
     */
  }, {
    key: "getGlobalOptions",
    value: function getGlobalOptions() {
      var _this$PRIVATE$options = this[PRIVATE].options,
        options = _this$PRIVATE$options === void 0 ? {} : _this$PRIVATE$options;
      return options;
    }

    /**
     * Initiates a client request. Will provide a potentially modified set of HTTP options that
     * should be used when actually submitting the request.
     *
     * @param {HttpBackend} backend Backend handling the current request.
     * @param {typedefs.RequestOptions} options Raw options as received from the consumer of the client.
     * @returns {Promise<typedefs.RequestOptions>} Resolves with the options that should be given to the
     *  underlying backend.
     */
  }, {
    key: "beginBackendRequest",
    value: function () {
      var _beginBackendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backend, options) {
        var httpOptions, clientCookies;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                httpOptions = backend.createHttpOptions(options);
                httpOptions.logInfo("> submitting request");
                httpOptions.mergeClientOptions(this.getGlobalOptions());
                if (!backend.shouldHandleCookies()) {
                  _context.next = 10;
                  break;
                }
                httpOptions.logDebug("applying any cookies in the client's jar");
                _context.next = 7;
                return this[_getClientCookies](httpOptions.getUrl());
              case 7:
                clientCookies = _context.sent;
                httpOptions.logDebug("adding ".concat(clientCookies.length, " cookies from the client's jar"));
                httpOptions.setAdditionalCookies(clientCookies);
              case 10:
                httpOptions.setStartTime(new Date().getTime());
                return _context.abrupt("return", backend.getRequestConfig(httpOptions));
              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function beginBackendRequest(_x, _x2) {
        return _beginBackendRequest.apply(this, arguments);
      }
      return beginBackendRequest;
    }()
    /**
     * Instructs the client that an HTTP request has finished, and that it has
     * a corresponding response.
     *
     * @param {HttpBackend} backend Underlying backend processing the request.
     * @param {typedefs.RequestOptions} options Raw options that initiated the request.
     * @param {*} response Response as provided by the underlying backend.
     * @returns {Promise} Resolves when the client is finished processing
     *  the response.
     */
  }, {
    key: "endBackendRequestWithResponse",
    value: function () {
      var _endBackendRequestWithResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(backend, options, response) {
        var httpOptions, httpResponse;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                httpOptions = backend.createHttpOptions(options);
                httpOptions.setEndTime(new Date().getTime());
                httpResponse = backend.createHttpResponse(response);
                httpOptions.logInfo("< ".concat(httpResponse.getStatus(), " finished request"));

                // record client cookies from response
                return _context2.abrupt("return", this[_setClientCookies](httpOptions, backend, httpResponse));
              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function endBackendRequestWithResponse(_x3, _x4, _x5) {
        return _endBackendRequestWithResponse.apply(this, arguments);
      }
      return endBackendRequestWithResponse;
    }()
    /**
     * Instructs the client that an HTTP request has finished, but it generated
     * an error.
     *
     * @param {HttpBackend} backend Underlying backend processing the request.
     * @param {typedefs.RequestOptions} options Raw options that initiated the request.
     * @param {*} error Error as provided by the underlying backend.
     * @returns {Promise} Resolves when the client is finished processing
     *  the error.
     */
  }, {
    key: "endBackendRequestWithError",
    value: function () {
      var _endBackendRequestWithError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(backend, options, error) {
        var httpOptions, errorDetails, _errorDetails, name, message;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                httpOptions = backend.createHttpOptions(options);
                httpOptions.setEndTime(new Date().getTime());
                errorDetails = error;
                _errorDetails = errorDetails, name = _errorDetails.name, message = _errorDetails.message;
                if (name || message) {
                  errorDetails = "".concat(name, ": ").concat(message);
                }
                httpOptions.logInfo("< ERR finished request. ".concat(errorDetails));
              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function endBackendRequestWithError(_x6, _x7, _x8) {
        return _endBackendRequestWithError.apply(this, arguments);
      }
      return endBackendRequestWithError;
    }()
    /**
     * Examines the response of an HTTP request and determines whether it qualifies for
     * a retry based on the retry strategies registered with the client.
     *
     * @param {HttpBackend} backend Underlying backend that's currently processing the
     *  request.
     * @param {typedefs.RequestOptions} rawOptions Options that were used to generate the response.
     * @param {*} [rawResponse] If provided, response as received from the underlying
     *  backend.
     * @param {*} [error] If provided, error that was provided by the underlying
     *  backend.
     * @returns {typedefs.RequestOptions} If falsy, indicates that no retry is required. If
     *  truthy, the raw options that should be used in the next attempt of the request.
     */
  }, {
    key: "getRetryOptionsFromResponse",
    value: function () {
      var _getRetryOptionsFromResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(backend, rawOptions, rawResponse, error) {
        var httpOptions, httpResponse, retryInfo, delay, requestOptions;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                httpOptions = backend.createHttpOptions(rawOptions);
                httpResponse = backend.createHttpResponse(rawResponse || {}, error);
                _context4.next = 4;
                return retryWithStrategies(httpOptions, backend, httpResponse, httpOptions.getRetries() + 1);
              case 4:
                retryInfo = _context4.sent;
                if (!retryInfo) {
                  _context4.next = 14;
                  break;
                }
                delay = retryInfo.delay, requestOptions = retryInfo.options;
                httpOptions.addRetry(httpResponse, delay);
                httpResponse.setRequestTime(httpOptions.getRequestTime());
                httpOptions.logInfo("request is being retried by a retry strategy. waiting ".concat(delay, " for attempt ").concat(httpOptions.getRetries(), "."));
                httpOptions.setRequestOptions(requestOptions);
                _context4.next = 13;
                return sleep(delay);
              case 13:
                return _context4.abrupt("return", backend.getRequestConfig(httpOptions));
              case 14:
                return _context4.abrupt("return", false);
              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function getRetryOptionsFromResponse(_x9, _x10, _x11, _x12) {
        return _getRetryOptionsFromResponse.apply(this, arguments);
      }
      return getRetryOptionsFromResponse;
    }()
    /**
     * Retrieves the final response that the client will provide to the consumer.
     *
     * @param {HttpBackend} backend Backend processing the current request.
     * @param {typedefs.RequestOptions} config Configuration that generated the client's response.
     * @param {*} [rawResponse] If applicable, raw response as provided by the underlying backend.
     * @param {*} [error] If applicable, error as provided by the underlying backend.
     * @returns {*} Response to a request.
     */
  }, {
    key: "getClientResponse",
    value: function getClientResponse(backend, config, rawResponse, error) {
      var httpOptions = backend.createHttpOptions(config);
      var httpResponse = backend.createHttpResponse(rawResponse, error);
      httpResponse.setRequestTime(httpOptions.getRequestTime());
      return httpResponse.toClientResponse({
        options: httpOptions.toJSON()
      });
    }

    /**
     * Retrieves the final error that the client will provide to the consumer.
     *
     * @param {HttpBackend} backend Backend processing the current request.
     * @param {typedefs.RequestOptions} config Configuration that generated the client's response.
     * @param {*} error Error as provided by the underlying backend.
     * @returns {*} Error to the request.
     */
  }, {
    key: "getClientError",
    value: function getClientError(backend, config, error) {
      var httpOptions = backend.createHttpOptions(config);
      var httpResponse = backend.createHttpResponse({}, error);
      httpResponse.setRequestTime(httpOptions.getRequestTime());
      return httpResponse.toClientResponse({
        options: httpOptions.toJSON()
      });
    }

    /**
     * Clears the cookies that the client is currently using.
     *
     * @returns {Promise} Resolves when the client's cookies have been cleared.
     */
  }, {
    key: "clearCookies",
    value: function clearCookies() {
      var cookieJar = this[PRIVATE].cookieJar;
      return cookieJar.removeAllCookies();
    }

    /**
     * Sets cookies in the client's internal jar. The operation is additive, so new cookies
     * will be added and existing cookies will be replaced.
     *
     * @param {string} url Full URL to which the cookies will apply.
     * @param {Array<string>} cookies List of raw cookie values to be added.
     * @returns {Promise} Resolves when the cookies have been set.
     */
  }, {
    key: "setCookies",
    value: function () {
      var _setCookies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url, cookies) {
        var cookieJar, i, cookie;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cookieJar = this[PRIVATE].cookieJar;
                i = 0;
              case 2:
                if (!(i < cookies.length)) {
                  _context5.next = 9;
                  break;
                }
                cookie = Cookie.parse(cookies[i]);
                _context5.next = 6;
                return cookieJar.setCookie(cookie, url);
              case 6:
                i++;
                _context5.next = 2;
                break;
              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function setCookies(_x13, _x14) {
        return _setCookies.apply(this, arguments);
      }
      return setCookies;
    }()
    /**
     * Retrieves the client's cookies from its internal jar.
     *
     * @param {string} url Full URL whose cookies should be retrieved.
     * @returns {Promise<Array<string>>} List of raw cookie values.
     */
  }, {
    key: "getCookies",
    value: function () {
      var _getCookies = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url) {
        var cookies;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this[_getClientCookies](url);
              case 2:
                cookies = _context6.sent;
                return _context6.abrupt("return", cookies.map(function (cookie) {
                  return cookie.toString();
                }));
              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function getCookies(_x15) {
        return _getCookies.apply(this, arguments);
      }
      return getCookies;
    }()
    /**
     * Updates the client's current cookies with set-cookie header of a given
     * response.
     *
     * @param {HttpOptions} options Options to use to submit the request.
     * @param {HttpBackend} backend Backend currently processing the request.
     * @param {HttpResponse} response HTTP response of a request. set-cookie header from
     *  the response will be used to update the client's cookies.
     * @returns {Promise} Resolves when all cookies have been set.
     */
  }, {
    key: _setClientCookies,
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options, backend, response) {
        var setCookie;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (backend.shouldHandleCookies()) {
                  _context7.next = 2;
                  break;
                }
                return _context7.abrupt("return");
              case 2:
                setCookie = backend.getSetCookies(response.getRawResponse());
                if (!setCookie.length) {
                  options.logDebug("no cookies received from set-cookie header, not setting cookies");
                }
                return _context7.abrupt("return", this.setCookies(options.getUrl(), setCookie));
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function value(_x16, _x17, _x18) {
        return _value.apply(this, arguments);
      }
      return value;
    }()
    /**
     * Retrieves the cookies that the client has received from the set-cookie headers
     * of responses it has made.
     *
     * @param {string} url Url whose cookies should be retrieved.
     * @returns {Promise<Array<Cookie>>} Additional cookies from the client's cookie
     *  jar.
     */
  }, {
    key: _getClientCookies,
    value: function () {
      var _value2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {
        var cookieJar;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                cookieJar = this[PRIVATE].cookieJar;
                return _context8.abrupt("return", cookieJar.getCookies(url));
              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function value(_x19) {
        return _value2.apply(this, arguments);
      }
      return value;
    }()
  }]);
  return HttpClient;
}();
module.exports = HttpClient;