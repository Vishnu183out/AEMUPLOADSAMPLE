"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var HttpResponse = require("../http-response");
var PRIVATE = Symbol("PRIVATE");

/**
 * @typedef {object} RetryOptions
 * @property {number} attempts The number of times that the client has made the
 *  request.
 * @property {number} maxAttempts The maximum number of times that the client has
 *  been configured to make the request. This value is not necessarily enforced
 *  by the client - it's simply informational and can be checked by the strategy
 *  if its logic involves a cap on the number of retry attempts.
 * @property {number} delayMultiple The delay multiple that the client has been
 *  configured to use when calculating the amount of time that the client should
 *  delay before making another retry attempt. This value is not necessarily
 *  used by the client - it's simply informational and can be used by the strategy
 *  its logic involves an exponential delay in the time that the client should
 *  wait between retries.
 * @property {HttpResponse} response The response to the HTTP request currently
 *  being examined to decide whether it should be retried.
 * @property {string} url The URL that was requested to generate the response.
 * @property {object} options Additional options that were used to initiate the request
 *  that generated the response.
 */

/**
 * @typedef {object} StrategyOptions
 * @property {Function} shouldRetry Should return a Promise that resolves to true if
 *  a request should be retried. Receives a single RetryOptions argument.
 * @property {Function} [getDelayMultiple] Should return a Promise that resolves to the
 *  value by which the delay should be multiplied depending on the retry number.
 *  Receives a single RetryOptions argument. Defaults to the multiple provided in
 *  the client's options.
 * @property {Function} [getMaxRetries] Should return a Promise that resolves to the
 *  maximum number of times that the request should be retried. Defaults to the
 *  value provided in the client's options.
 */

/**
 * Represents one or more strategies that the HTTP client will use to determine whether a
 * request should be retried or not. These strategies can be provided by consumers of
 * the client to control the client's retry logic.
 *
 * There are several out-of-the-box strategies that the library provides, but the client
 * is free to supply their own custom strategies as well. The client uses a default set
 * of strategies related to retrying certain error responses.
 */
var RetryStrategy = /*#__PURE__*/function () {
  /**
   * Constructs a new strategy that uses the given options for its functionality.
   *
   * @param {StrategyOptions} [strategyOptions] Options for controlling how the
   *  strategy behaves.
   */
  function RetryStrategy() {
    var strategyOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, RetryStrategy);
    this[PRIVATE] = {
      options: strategyOptions
    };
  }

  /**
   * Determines whether a given http request should be retried based on the response
   * that was received.
   *
   * The default implementation returns true if the number of attempts is less than
   * the maximum number of attempts.
   *
   * One thing to note is that this method could be called for both failed _and_
   * successful requests. Be sure to handle either case accordingly.
   *
   * @param {RetryOptions} retryOptions Information about the current request, which
   *  can be used to determine whether a retry is in order.
   * @returns {Promise<boolean>} True if the request should be retried, false otherwise.
   */
  _createClass(RetryStrategy, [{
    key: "shouldRetry",
    value: function () {
      var _shouldRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(retryOptions) {
        var _this$PRIVATE$options, retryFromOptions;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this$PRIVATE$options = this[PRIVATE].options.shouldRetry, retryFromOptions = _this$PRIVATE$options === void 0 ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          return _context.abrupt("return", false);
                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })) : _this$PRIVATE$options;
                return _context2.abrupt("return", retryFromOptions(retryOptions));
              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function shouldRetry(_x) {
        return _shouldRetry.apply(this, arguments);
      }
      return shouldRetry;
    }()
    /**
     * Retrieves the value by which the configured retry delay should be multiplied to
     * determine the amount of time the client should wait before making another retry
     * attempt.
     *
     * @param {RetryOptions} retryOptions Information about the current request, which
     *  can be used to determine the multiple.
     * @returns {Promise<number>} Delay multiple.
     */
  }, {
    key: "getRetryDelayMultiple",
    value: function () {
      var _getRetryDelayMultiple = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(retryOptions) {
        var _this$PRIVATE$options2, getDelayMultiple;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _this$PRIVATE$options2 = this[PRIVATE].options.getDelayMultiple, getDelayMultiple = _this$PRIVATE$options2 === void 0 ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          return _context3.abrupt("return", retryOptions.delayMultiple);
                        case 1:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                })) : _this$PRIVATE$options2;
                return _context4.abrupt("return", getDelayMultiple(retryOptions));
              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function getRetryDelayMultiple(_x2) {
        return _getRetryDelayMultiple.apply(this, arguments);
      }
      return getRetryDelayMultiple;
    }()
    /**
     * Retrieves the amount of time, in milliseconds, that the retry should be delayed. Note
     * that the retry delay multiple will be used to expentially increase this delay with
     * each retry.
     *
     * @param {RetryOptions} retryOptions Information about the current request, which
     *  can be used to determine the delay.
     * @returns {Promise<number>} Retry delay.
     */
  }, {
    key: "getRetryDelay",
    value: function () {
      var _getRetryDelay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(retryOptions) {
        var _this$PRIVATE$options3, getDelay;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _this$PRIVATE$options3 = this[PRIVATE].options.getDelay, getDelay = _this$PRIVATE$options3 === void 0 ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          return _context5.abrupt("return", retryOptions.delay);
                        case 1:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })) : _this$PRIVATE$options3;
                return _context6.abrupt("return", getDelay(retryOptions));
              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function getRetryDelay(_x3) {
        return _getRetryDelay.apply(this, arguments);
      }
      return getRetryDelay;
    }()
    /**
     * Retrieves the maximum number of times that a request should be retried according to
     * the strategy.
     *
     * @param {RetryOptions} retryOptions Information about the current request, which
     *  can be used to determine the count.
     * @returns {Promise<number>} Retry count.
     */
  }, {
    key: "getMaxRetryCount",
    value: function () {
      var _getMaxRetryCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(retryOptions) {
        var _this$PRIVATE$options4, getMaxRetries;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _this$PRIVATE$options4 = this[PRIVATE].options.getMaxRetries, getMaxRetries = _this$PRIVATE$options4 === void 0 ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          return _context7.abrupt("return", retryOptions.maxAttempts);
                        case 1:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7);
                })) : _this$PRIVATE$options4;
                return _context8.abrupt("return", getMaxRetries(retryOptions));
              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function getMaxRetryCount(_x4) {
        return _getMaxRetryCount.apply(this, arguments);
      }
      return getMaxRetryCount;
    }()
    /**
     * Retrieves the raw options that will be given to the underlying HTTP library on the
     * next retry.
     *
     * @param {RetryOptions} retryOptions Information about the current request, which
     *  can be used to determine the options.
     * @returns {Promise<object>} Raw request options.
     */
  }, {
    key: "getRetryRequestOptions",
    value: function () {
      var _getRetryRequestOptions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(retryOptions) {
        var _this$PRIVATE$options5, getRequestOptions;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _this$PRIVATE$options5 = this[PRIVATE].options.getRequestOptions, getRequestOptions = _this$PRIVATE$options5 === void 0 ? /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          return _context9.abrupt("return", {});
                        case 1:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                })) : _this$PRIVATE$options5;
                return _context10.abrupt("return", getRequestOptions(retryOptions));
              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));
      function getRetryRequestOptions(_x5) {
        return _getRetryRequestOptions.apply(this, arguments);
      }
      return getRetryRequestOptions;
    }()
  }]);
  return RetryStrategy;
}();
module.exports = RetryStrategy;