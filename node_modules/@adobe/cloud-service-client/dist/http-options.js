"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/*
Copyright 2021 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var _require = require("tough-cookie"),
  Cookie = _require.Cookie,
  CookieJar = _require.CookieJar;
var _require2 = require("uuid"),
  uuid = _require2.v4;
var _require3 = require("./http-utils"),
  objectToJson = _require3.objectToJson,
  parseCookieHeader = _require3.parseCookieHeader,
  buildCookieLookup = _require3.buildCookieLookup;
var DefaultLogger = require("./default-logger");
var ErrorStatusCode = require("./retry-strategies/error-status-code");
var NetworkError = require("./retry-strategies/network-error");
var RetryStrategy = require("./retry-strategies/retry-strategy");
var EventuallyConsistentCreate = require("./retry-strategies/eventually-consistent-create");
var EventuallyConsistentUpdate = require("./retry-strategies/eventually-consistent-update");
var EventuallyConsistentDelete = require("./retry-strategies/eventually-consistent-delete");
var HttpResponse = require("./http-response");
var _require4 = require("./constants"),
  DEFAULT_TIMEOUT = _require4.DEFAULT_TIMEOUT;
var typedefs = require("./typedefs");
var DEFAULT_RETRY_COUNT = 3;
var DEFAULT_RETRY_DELAY = 1000;
var DEFAULT_RETRY_DELAY_MULTIPLE = 2;

// private methods
var PRIVATE = Symbol("PRIVATE");
var _getRetryOptions = Symbol("_getRetryOptions");
var _getCookieLookup = Symbol("_getCookieLookup");
var _log = Symbol("_log");
var HttpOptions = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the options class that uses the given raw set
   * of options.
   *
   * @param {typedefs.RequestOptions} [options] Options as passed in by a consumer.
   * @param {typedefs.ClientOptions} [clientOptions] Client-level options as
   *  provided when the client was created.
   */
  function HttpOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var clientOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, HttpOptions);
    this[PRIVATE] = {
      options: options,
      clientOptions: clientOptions
    };
  }

  /**
   * Retrieves the URL to be requested by the client.
   *
   * @returns {string} An HTTP URL.
   */
  _createClass(HttpOptions, [{
    key: "getUrl",
    value: function getUrl() {
      var _this$getOptions = this.getOptions(),
        url = _this$getOptions.url;
      return url;
    }

    /**
     * Retrieves the method to be used in a request.
     *
     * @returns {string} An HTTP method.
     */
  }, {
    key: "getMethod",
    value: function getMethod() {
      var _this$getOptions2 = this.getOptions(),
        _this$getOptions2$met = _this$getOptions2.method,
        method = _this$getOptions2$met === void 0 ? "GET" : _this$getOptions2$met;
      return method;
    }

    /**
     * Retrieves the number of times that the request has been retried so far.
     *
     * @returns {number} Retry count.
     */
  }, {
    key: "getRetries",
    value: function getRetries() {
      var _this$getClientOption = this.getClientOptions(),
        _this$getClientOption2 = _this$getClientOption.retries,
        retries = _this$getClientOption2 === void 0 ? 0 : _this$getClientOption2;
      return retries;
    }

    /**
     * Retrieves the total amount of time, in milliseconds, that the request has spent
     * waiting between retries.
     *
     * @returns {number} Timespan in milliseconds.
     */
  }, {
    key: "getRetryWait",
    value: function getRetryWait() {
      var _this$getClientOption3 = this.getClientOptions(),
        _this$getClientOption4 = _this$getClientOption3.retryWait,
        retryWait = _this$getClientOption4 === void 0 ? 0 : _this$getClientOption4;
      return retryWait;
    }

    /**
     * Retrieves the responses that qualified for retries for the current request.
     *
     * @returns {Array<*>} Array of responses registered with the options.
     */
  }, {
    key: "getRetryResponses",
    value: function getRetryResponses() {
      var _this$getClientOption5 = this.getClientOptions(),
        _this$getClientOption6 = _this$getClientOption5.retryResponses,
        retryResponses = _this$getClientOption6 === void 0 ? [] : _this$getClientOption6;
      return retryResponses;
    }

    /**
     * Retrieves the amount of time, in milliseconds, that it took for the most recent
     * request's response to be provided by the underlying HTTP backend.
     *
     * @returns {number} Timespan in milliseconds.
     */
  }, {
    key: "getRequestTime",
    value: function getRequestTime() {
      var _this$getClientOption7 = this.getClientOptions(),
        startTime = _this$getClientOption7.startTime,
        endTime = _this$getClientOption7.endTime;
      if (startTime && endTime) {
        return endTime - startTime;
      }
      return 0;
    }

    /**
     * Sets the raw HTTP request options upon which the client's options are based. This will merge
     * the current options with the given options.
     *
     * @param {typedefs.RequestOptions} options Raw HTTP request options.
     */
  }, {
    key: "setRequestOptions",
    value: function setRequestOptions(options) {
      this[PRIVATE].options = _objectSpread(_objectSpread({}, this[PRIVATE].options), options);
    }

    /**
     * Records the start time of the most recent request.
     *
     * @param {number} startTime Timestamp, in milliseconds.
     */
  }, {
    key: "setStartTime",
    value: function setStartTime(startTime) {
      this.addClientOptions({
        startTime: startTime,
        endTime: 0
      });
    }

    /**
     * Records the end time of the most recent request.
     *
     * @param {number} endTime Timestamp, in milliseconds.
     */
  }, {
    key: "setEndTime",
    value: function setEndTime(endTime) {
      this.addClientOptions({
        endTime: endTime
      });
    }

    /**
     * Adds information about a retry to the options. The method will add the given response
     * information to the options' retryResponses, increment the options' retries count,
     * and add the given delay to the options' retryWait value.
     *
     * @param {HttpResponse} response Response to add to the option's retryResponses.
     * @param {number} retryDelay Timespan, in milliseconds, to add to the options' retryWait.
     */
  }, {
    key: "addRetry",
    value: function addRetry(response, retryDelay) {
      var clientOptions = this.getClientOptions();
      var _clientOptions$retrie = clientOptions.retries,
        retries = _clientOptions$retrie === void 0 ? 0 : _clientOptions$retrie,
        _clientOptions$retryW = clientOptions.retryWait,
        retryWait = _clientOptions$retryW === void 0 ? 0 : _clientOptions$retryW,
        _clientOptions$retryR = clientOptions.retryResponses,
        retryResponses = _clientOptions$retryR === void 0 ? [] : _clientOptions$retryR;
      retryResponses.push(response.toJSON());
      var newOptions = {
        retries: retries + 1,
        retryWait: retryWait + retryDelay,
        retryResponses: retryResponses
      };
      this.addClientOptions(newOptions);
    }

    /**
     * Retrieves the strategies that will be used to determine if a request by the
     * client should be retried.
     *
     * Each strategy is responsible for examining a response and determining whether
     * it warrants a retry. The client will initiate a retry based on the first
     * strategy that indicates a retry is necessary.
     *
     * @returns {Array<typedefs.RetryStrategy>} Strategies to use to initiate retries.
     */
  }, {
    key: "getRetryStrategies",
    value: function getRetryStrategies() {
      var _this$getClientOption8 = this.getClientOptions(),
        _this$getClientOption9 = _this$getClientOption8.eventuallyConsistentCreate,
        eventuallyConsistentCreate = _this$getClientOption9 === void 0 ? false : _this$getClientOption9,
        _this$getClientOption10 = _this$getClientOption8.eventuallyConsistentUpdate,
        eventuallyConsistentUpdate = _this$getClientOption10 === void 0 ? false : _this$getClientOption10,
        _this$getClientOption11 = _this$getClientOption8.eventuallyConsistentDelete,
        eventuallyConsistentDelete = _this$getClientOption11 === void 0 ? false : _this$getClientOption11;
      var allStrategies = [new ErrorStatusCode(), new NetworkError()];
      var _this$_getRetryOption = this[_getRetryOptions](),
        _this$_getRetryOption2 = _this$_getRetryOption.strategies,
        strategies = _this$_getRetryOption2 === void 0 ? [] : _this$_getRetryOption2;
      strategies.forEach(function (strategy) {
        allStrategies.push(new RetryStrategy(strategy));
      });
      if (eventuallyConsistentCreate) {
        allStrategies.push(new EventuallyConsistentCreate());
      }
      if (eventuallyConsistentUpdate) {
        allStrategies.push(new EventuallyConsistentUpdate());
      }
      if (eventuallyConsistentDelete) {
        allStrategies.push(new EventuallyConsistentDelete());
      }
      return allStrategies;
    }

    /**
     * Gets the amount of time, in milliseconds, that the client should wait before
     * retrying a failed request.
     *
     * The client will use this value in conjunction with a retry delay to determine
     * the total delay based on the number of retry attempts.
     *
     * Default is 1000.
     *
     * @returns {number} Time span in milliseconds.
     */
  }, {
    key: "getRetryDelay",
    value: function getRetryDelay() {
      var _this$_getRetryOption3 = this[_getRetryOptions](),
        _this$_getRetryOption4 = _this$_getRetryOption3.delay,
        delay = _this$_getRetryOption4 === void 0 ? DEFAULT_RETRY_DELAY : _this$_getRetryOption4;
      return delay;
    }

    /**
     * Retrieves the number that the retry delay should be multiplied by each time a
     * request is retried.
     *
     * For example, assume the delay multiple is 2 and the delay is 1000 (one second).
     * The first time the client retries it a request it will wait 1 second, then 2
     * seconds the next attempt, then 4 seconds, then 8 seconds, etc.
     *
     * This multiple will only be used when a retry strategy doesn't provide its own
     * value.
     *
     * Default is 2.
     *
     * @returns {number} Delay multiplier.
     */
  }, {
    key: "getRetryDelayMultiple",
    value: function getRetryDelayMultiple() {
      var _this$_getRetryOption5 = this[_getRetryOptions](),
        _this$_getRetryOption6 = _this$_getRetryOption5.delayMultiple,
        delayMultiple = _this$_getRetryOption6 === void 0 ? DEFAULT_RETRY_DELAY_MULTIPLE : _this$_getRetryOption6;
      return delayMultiple;
    }

    /**
     * Gets the number of times that the client should retry a request before
     * giving up.
     *
     * This count will be provided to each retry strategy, but it's ultimately
     * up to the strategy to honor it.
     *
     * Default is 3.
     *
     * @returns {number} Number of retries.
     */
  }, {
    key: "getMaxRetries",
    value: function getMaxRetries() {
      var _this$_getRetryOption7 = this[_getRetryOptions](),
        _this$_getRetryOption8 = _this$_getRetryOption7.count,
        count = _this$_getRetryOption8 === void 0 ? DEFAULT_RETRY_COUNT : _this$_getRetryOption8;
      return count;
    }

    /**
     * Retrieves the timeout value, in milliseconds, as specified in the client's
     * options.
     *
     * @returns {number} Timespan in milliseconds.
     */
  }, {
    key: "getTimeout",
    value: function getTimeout() {
      var _this$getClientOption12 = this.getClientOptions(),
        _this$getClientOption13 = _this$getClientOption12.timeout,
        timeout = _this$getClientOption13 === void 0 ? DEFAULT_TIMEOUT : _this$getClientOption13;
      return timeout;
    }

    /**
     * Retrieves the cookies that the options are currently using.
     *
     * @returns {Promise<CookieJar>} Cookie jar containing the cookies for
     *  the options.
     */
  }, {
    key: "getCookieJar",
    value: function () {
      var _getCookieJar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var cookies, cookieJar, cookieList, _this$getOptions3, _this$getOptions3$hea, headers, headerNames, cookieHeader, i, url, _i;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cookies = this[PRIVATE].cookies;
                if (cookies) {
                  _context.next = 26;
                  break;
                }
                cookieJar = new CookieJar();
                cookieList = [];
                _this$getOptions3 = this.getOptions(), _this$getOptions3$hea = _this$getOptions3.headers, headers = _this$getOptions3$hea === void 0 ? {} : _this$getOptions3$hea; // ensure cookie header name is case insensitive
                headerNames = Object.keys(headers);
                cookieHeader = "";
                i = 0;
              case 8:
                if (!(i < headerNames.length)) {
                  _context.next = 15;
                  break;
                }
                if (!(String(headerNames[i]).toLowerCase() === "cookie")) {
                  _context.next = 12;
                  break;
                }
                cookieHeader = headers[headerNames[i]];
                return _context.abrupt("break", 15);
              case 12:
                i++;
                _context.next = 8;
                break;
              case 15:
                // parse cookie header if provided
                if (cookieHeader) {
                  cookieList = parseCookieHeader(cookieHeader);
                }

                // add cookies to options jar for the current url
                url = this.getUrl();
                _i = 0;
              case 18:
                if (!(_i < cookieList.length)) {
                  _context.next = 25;
                  break;
                }
                this.logDebug("adding cookie \"".concat(cookieList[_i].key, "\" from header to options jar"));
                _context.next = 22;
                return cookieJar.setCookie(cookieList[_i], url);
              case 22:
                _i++;
                _context.next = 18;
                break;
              case 25:
                this[PRIVATE].cookies = cookieJar;
              case 26:
                return _context.abrupt("return", this[PRIVATE].cookies);
              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function getCookieJar() {
        return _getCookieJar.apply(this, arguments);
      }
      return getCookieJar;
    }()
    /**
     * Sets additional cookies that will be included in the HTTP options. Note that only
     * the options will only include cookies that have not already been explicitly
     * specified in the options' cookie header.
     *
     * @param {Array<Cookie>} cookies Cookies to be added to the options.
     */
  }, {
    key: "setAdditionalCookies",
    value: function setAdditionalCookies(cookies) {
      this[PRIVATE].addlCookies = cookies;
    }

    /**
     * Converts the raw options into a set of configurations that can be used to submit
     * an HTTP request.
     *
     * @returns {Promise<typedefs.RequestOptions>} Will be resolved with the configuration that can be
     *  used in an HTTP request.
     */
  }, {
    key: "toRequestConfig",
    value: function () {
      var _toRequestConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var options, _this$PRIVATE$addlCoo, addlCookies, cookies, jar, cookieLookup, i, key, cookie, _options$headers, headers;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _objectSpread({}, this.getOptions());
                _this$PRIVATE$addlCoo = this[PRIVATE].addlCookies, addlCookies = _this$PRIVATE$addlCoo === void 0 ? [] : _this$PRIVATE$addlCoo;
                if (!addlCookies.length) {
                  _context2.next = 29;
                  break;
                }
                cookies = _toConsumableArray(addlCookies); // cookies will be added to the options' jar. no need to remember them anymore
                this[PRIVATE].addlCookies = [];

                // if there are additional cookies, overwrite whatever cookie header may have been
                // provided with the contents of the options' jar (created from the options' cookie
                // header), plus the additional cookies.
                _context2.next = 7;
                return this.getCookieJar();
              case 7:
                jar = _context2.sent;
                _context2.next = 10;
                return this[_getCookieLookup](jar);
              case 10:
                cookieLookup = _context2.sent;
                this.logDebug("adding ".concat(cookies.length, " to options cookie jar, which already has ").concat(Object.keys(cookieLookup).length, " cookies"));

                // merge the additional cookies with current cookies
                i = 0;
              case 13:
                if (!(i < cookies.length)) {
                  _context2.next = 25;
                  break;
                }
                key = cookies[i].key;
                if (cookieLookup[key]) {
                  _context2.next = 21;
                  break;
                }
                this.logDebug("adding cookie \"".concat(key, "\" from client jar to options jar"));
                _context2.next = 19;
                return jar.setCookie(cookies[i], this.getUrl());
              case 19:
                _context2.next = 22;
                break;
              case 21:
                this.logDebug("skipping cookie \"".concat(key, "\" from client jar because it's already in the options jar"));
              case 22:
                i++;
                _context2.next = 13;
                break;
              case 25:
                _context2.next = 27;
                return jar.getCookieString(this.getUrl());
              case 27:
                cookie = _context2.sent;
                if (cookie) {
                  _options$headers = options.headers, headers = _options$headers === void 0 ? {} : _options$headers;
                  options.headers = _objectSpread(_objectSpread({}, headers), {}, {
                    cookie: cookie
                  });
                }
              case 29:
                return _context2.abrupt("return", options);
              case 30:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function toRequestConfig() {
        return _toRequestConfig.apply(this, arguments);
      }
      return toRequestConfig;
    }()
    /**
     * Logs a message at the debug level using the logger provided in the options.
     *
     * @param {Array<any>} theArguments Arguments to use to format the message.
     */
  }, {
    key: "logDebug",
    value: function logDebug() {
      for (var _len = arguments.length, theArguments = new Array(_len), _key = 0; _key < _len; _key++) {
        theArguments[_key] = arguments[_key];
      }
      this[_log]("debug", theArguments);
    }

    /**
     * Logs a message at the info level using the logger provided in the options.
     *
     * @param {Array<any>} theArguments Arguments to use to format the message.
     */
  }, {
    key: "logInfo",
    value: function logInfo() {
      for (var _len2 = arguments.length, theArguments = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        theArguments[_key2] = arguments[_key2];
      }
      this[_log]("info", theArguments);
    }

    /**
     * Logs a message at the warn level using the logger provided in the options.
     *
     * @param {Array<any>} theArguments Arguments to use to format the message.
     */
  }, {
    key: "logWarn",
    value: function logWarn() {
      for (var _len3 = arguments.length, theArguments = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        theArguments[_key3] = arguments[_key3];
      }
      this[_log]("warn", theArguments);
    }

    /**
     * Logs a message at the error level using the logger provided in the options.
     *
     * @param {Array<any>} theArguments Arguments to use to format the message.
     */
  }, {
    key: "logError",
    value: function logError() {
      for (var _len4 = arguments.length, theArguments = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        theArguments[_key4] = arguments[_key4];
      }
      this[_log]("error", theArguments);
    }

    /**
     * Retrieves the request ID that the options are currently using. Will use the
     * x-request-id header if provided in the initial options; will generate its
     * own if none provided.
     *
     * @returns {string} The request ID for the options.
     */
  }, {
    key: "getRequestId",
    value: function getRequestId() {
      if (!this[PRIVATE].requestId) {
        var _this$getOptions4 = this.getOptions(),
          _this$getOptions4$hea = _this$getOptions4.headers,
          headers = _this$getOptions4$hea === void 0 ? {} : _this$getOptions4$hea;
        this[PRIVATE].requestId = headers["x-request-id"] || uuid();
      }
      return this[PRIVATE].requestId;
    }

    /**
     * Retrieves the full set of options as provided in the class constructor.
     *
     * @returns {typedefs.RequestOptions} Raw HTTP config as passed into a request.
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      var _this$PRIVATE$options = this[PRIVATE].options,
        options = _this$PRIVATE$options === void 0 ? {} : _this$PRIVATE$options;
      return options;
    }

    /**
     * Retrieves the HTTP client-specific options from the raw HTTP config
     * as passed into the class constructor.
     *
     * @returns {typedefs.ClientRequestOptions} Options specific to the HTTP client.
     */
  }, {
    key: "getClientOptions",
    value: function getClientOptions() {
      var _this$PRIVATE$options2 = this[PRIVATE].options,
        options = _this$PRIVATE$options2 === void 0 ? {} : _this$PRIVATE$options2;
      var _options$cloudClient = options.cloudClient,
        cloudClient = _options$cloudClient === void 0 ? {} : _options$cloudClient;
      return cloudClient;
    }

    /**
     * Adds values to the client-specific options of the HTTP config. The
     * operation is additive, so new values will be added and existing
     * values overwritten.
     *
     * @param {typedefs.ClientRequestOptions} options Values to add.
     */
  }, {
    key: "addClientOptions",
    value: function addClientOptions(options) {
      var clientOptions = this.getClientOptions();
      this[PRIVATE].options.cloudClient = _objectSpread(_objectSpread({}, clientOptions), options);
    }

    /**
     * Merges a given set of client-specific request options with whichever client
     * request options are already specified. Note the options that aren't already
     * present in the http options will be added, but duplicate options will
     * _not_ be overwritten.
     *
     * @param {typedefs.ClientRequestOptions} options Client-specific request options
     *  to merge.
     */
  }, {
    key: "mergeClientOptions",
    value: function mergeClientOptions(options) {
      var clientOptions = this.getClientOptions();
      var _clientOptions$retry = clientOptions.retry,
        existingRetry = _clientOptions$retry === void 0 ? {} : _clientOptions$retry;
      var _existingRetry$strate = existingRetry.strategies,
        existingStrategies = _existingRetry$strate === void 0 ? [] : _existingRetry$strate;
      var _options$retry = options.retry,
        retry = _options$retry === void 0 ? {} : _options$retry;
      var _retry$strategies = retry.strategies,
        strategies = _retry$strategies === void 0 ? [] : _retry$strategies;
      var newOptions = _objectSpread(_objectSpread({}, options), clientOptions);
      if (Object.keys(existingRetry).length || Object.keys(retry).length) {
        newOptions.retry = _objectSpread(_objectSpread({}, retry), existingRetry);
        if (existingStrategies.length || strategies.length) {
          newOptions.retry.strategies = [].concat(_toConsumableArray(existingStrategies), _toConsumableArray(strategies));
        }
      }
      this[PRIVATE].options.cloudClient = newOptions;
    }

    /**
     * Converts the options to a JSON representation.
     *
     * @returns {object} Simple object representing the options.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var jsonOptions = _objectSpread({}, this.getOptions());
      var _jsonOptions$headers = jsonOptions.headers,
        headers = _jsonOptions$headers === void 0 ? {} : _jsonOptions$headers;
      jsonOptions.headers = _objectSpread(_objectSpread({}, headers), {}, {
        "x-request-id": this.getRequestId()
      });
      var cloudClient = _objectSpread({
        retries: this.getRetries(),
        retryWait: this.getRetryWait(),
        retryResponses: this.getRetryResponses()
      }, this.getClientOptions());
      if (cloudClient.retry) {
        if (cloudClient.retry.strategies) {
          delete cloudClient.retry.strategies;
        }
      }
      jsonOptions.cloudClient = cloudClient;
      return objectToJson(jsonOptions);
    }

    /**
     * Converts the options to a stringified version of its JSON.
     *
     * @returns {string} The options' JSON as a string.
     */
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.toJSON(), null, 2);
    }

    /**
     * Retrieves the retry option element of the HTTP options.
     *
     * @returns {typedefs.RetryOptions} Retry information from the options.
     */
  }, {
    key: _getRetryOptions,
    value: function value() {
      var _this$getClientOption14 = this.getClientOptions(),
        _this$getClientOption15 = _this$getClientOption14.retry,
        retry = _this$getClientOption15 === void 0 ? {} : _this$getClientOption15;
      return retry;
    }

    /**
     * Builds a cookie lookup for a given cookie jar. The lookup's keys will
     * be the key property of all cookies in the lookup. Values will be the
     * Cookie representing the corresponding key.
     *
     * @param {CookieJar} cookieJar Jar whose cookies will be used.
     * @returns {Promise<object>} Simple javascript object.
     */
  }, {
    key: _getCookieLookup,
    value: function () {
      var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cookieJar) {
        var cookies;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return cookieJar.getCookies(this.getUrl());
              case 2:
                cookies = _context3.sent;
                return _context3.abrupt("return", buildCookieLookup(cookies));
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function value(_x) {
        return _value.apply(this, arguments);
      }
      return value;
    }()
    /**
     * Logs a message using the options' logger at the given level. Includes helpful information
     * specific to the options in the message.
     *
     * @param {string} logMethod Name of the method from the logger to use.
     * @param {Array} theArguments Arguments that will be applied to the log method.
     */
  }, {
    key: _log,
    value: function value(logMethod, theArguments) {
      var _this$getOptions5 = this.getOptions(),
        _this$getOptions5$met = _this$getOptions5.method,
        method = _this$getOptions5$met === void 0 ? "GET" : _this$getOptions5$met,
        url = _this$getOptions5.url;
      var _this$PRIVATE$clientO = this[PRIVATE].clientOptions,
        clientOptions = _this$PRIVATE$clientO === void 0 ? {} : _this$PRIVATE$clientO;
      var _clientOptions$log = clientOptions.log,
        log = _clientOptions$log === void 0 ? new DefaultLogger() : _clientOptions$log;
      log[logMethod].apply(log, DefaultLogger.prependToMessage("[".concat(new Date().toISOString(), "][").concat(this.getRequestId(), "] [").concat(method, "] [").concat(url, "] "), theArguments));
    }
  }]);
  return HttpOptions;
}();
module.exports = HttpOptions;