"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var Path = require('path');
var Async = require('async');
var AsyncLock = require('async-lock');
var fs = require('./fs-promise');
var _require = require('./constants'),
  DefaultValues = _require.DefaultValues;
var UploadError = require('./upload-error');
var ErrorCodes = require('./error-codes');
var lock = new AsyncLock();
var TEMP_PATTERNS = [/^\/~(.*)/,
// catch all paths starting with ~
/^\/\.(.*)/ // catch all paths starting with .
];

var TEMP_NAME_PATTERNS = [/^[.~]/i, /^TestFile/,
// InDesign: on file open, InDesign creates .dat.nosync* file, renames it TestFile, and deletes it
/\.tmp$/i,
// Illustrator: on save, creates one or more *.tmp files, renames them to original file name
/\.~tmp$/i,
// some default Windows applications use this file format
// Windows
/^desktop\.ini/i, /^Thumbs\.db/i, /^Adobe Bridge Cache\.bc$/i, /^Adobe Bridge Cache\.bct$/i];

/**
 * Loops through a given array, concurrently invoking the given callback. The loop will have a
 * maximum number of pending itemCallbacks at any one time. For example, if there are 100 items
 * in the array and 5 itemCallbacks are currently processing, then no more itemCallbacks will be
 * invoked until at least one of the pending itemCallbacks completes.
 *
 * @param {Array} loopArray Array to loop through.
 * @param {number} [maxConcurrent] Optionally specify how many concurrent itemCallbacks are allowed.
 *  Default is 5.
 * @param {function} itemCallback Invoked each time an item from the given array is available. Will
 *  be invoked with two parameters: the item itself and the index of the item in the array. The
 *  return value of this callback is expected to be a Promise.
 * @returns {Promise} Will be resolved when all Promises returned by the callback have been
 *  resolved. Will be resolved with an Array of all resolve values from the callback's Promises.
 */
function concurrentLoop(loopArray, maxConcurrent, itemCallback) {
  var theMaxConcurrent = maxConcurrent;
  var theItemCallback = itemCallback;
  if (typeof maxConcurrent === 'function') {
    theItemCallback = maxConcurrent;
    theMaxConcurrent = DefaultValues.MAX_CONCURRENT;
  }
  return new Promise(function (resolve, reject) {
    Async.eachOfLimit(loopArray, theMaxConcurrent, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(loopItem, index) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", theItemCallback(loopItem, index));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }(), function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });
  });
}

/**
 * Calculates the average of all the numbers in an array.
 *
 * @param {Array} values List of numbers for which to calculate an average.
 * @returns {number} The average value, rounded to zero decimal places.
 */
function getAverage(values) {
  if (values.length) {
    var sum = values.reduce(function (x, y) {
      return x + y;
    });
    return Math.round(sum / values.length);
  }
  return 0;
}
function buildCharRegex(charArray) {
  var regex = '[';
  charArray.forEach(function (char) {
    if (char === '\\' || char === ']') {
      regex += '\\';
    }
    regex += char;
  });
  regex += ']';
  return regex;
}

/**
 * Removes a given set of characters from the end of a string.
 *
 * @param {string} toTrim The value to be trimmed.
 * @param {Array} charArray An array of single characters to trim.
 */
function trimRight(toTrim, charArray) {
  if (toTrim && toTrim.replace) {
    return toTrim.replace(new RegExp("".concat(buildCharRegex(charArray), "*$"), 'g'), '');
  }
  return toTrim;
}

/**
 * Removes a given set of characters from the beginning of a string.
 *
 * @param {string} toTrim The value to be trimmed.
 * @param {Array} charArray An array of single characters to trim.
 */
function trimLeft(toTrim, charArray) {
  if (toTrim && toTrim.replace) {
    return toTrim.replace(new RegExp("^".concat(buildCharRegex(charArray), "*"), 'g'), '');
  }
  return toTrim;
}

/**
 * Joins a list of values together to form a URL path. Each of the given values
 * is guaranteed to be separated from all other values by a forward slash.
 *
 * @param  {...string} theArguments Any number of parameters to join.
 */
function joinUrlPath() {
  var path = '';
  for (var _len = arguments.length, theArguments = new Array(_len), _key = 0; _key < _len; _key++) {
    theArguments[_key] = arguments[_key];
  }
  theArguments.forEach(function (arg) {
    var toJoin = trimRight(trimLeft(arg, ['/']), ['/']);
    if (toJoin) {
      path += "/".concat(toJoin);
    }
  });
  return path;
}

/**
 * Removes "/content/dam" from the beginning of a given path, if its
 * present. If the path equals "/content/dam" then the method will
 * return an empty string.
 *
 * @param {string} path The path to trim.
 */
function trimContentDam(path) {
  if (!path) {
    return path;
  }
  if (path === '/content/dam') {
    return '';
  }
  var trimmed = String(path);
  if (trimmed.startsWith('/content/dam/')) {
    trimmed = trimmed.substr('/content/dam'.length);
  }
  return trimRight(trimmed, ['/']);
}

/**
 * Normalizes a path by ensuring it only contains forward slashes and does not end with a
 * slash. If the given path is falsy then the method will return an empty string.
 * @param {string} path An item's full path.
 * @returns {string} Normalized version of a path.
 */
function normalizePath(path) {
  var normPath = path;
  if (normPath) {
    normPath = normPath.replace(/\\/g, '/');
    if (normPath.charAt(normPath.length - 1) === '/') {
      normPath = normPath.substr(0, normPath.length - 1);
    }
  }
  return normPath || '';
}

/**
 * Determines whether or not a given path is either a temp file, or in a temp directory.
 * @param {string} path A file system-like path.
 * @returns {boolean} True if the path is a temp file, false otherwise.
 */
function isTempPath(path) {
  var tempPath = normalizePath(path);
  if (tempPath === '/') {
    return false;
  }
  var isTemp = TEMP_PATTERNS.some(function (pattern) {
    return pattern.test(tempPath);
  });
  if (!isTemp) {
    var pathName = Path.basename(tempPath);
    isTemp = TEMP_NAME_PATTERNS.some(function (pattern) {
      return pattern.test(pathName);
    });
  }
  return isTemp;
}

/**
 * Concurrently loops through all items in a directory, doing a stat
 * on each to determine if it's a directory or file. The method will
 * skip temp files and directories.
 * @param {string} directoryPath Full path to the directory to iterate.
 * @param {Array} directories All of the target directory's valid sub-directories
 *  will be added to this array.
 * @param {Array} files All of the target directory's valid sub-files will be
 *  added to this array.
 * @param {Array} errors Any errors encountered while processing the directory will
 *  be added to this array.
 * @returns {number} Total size, in bytes, of all files in the directory.
 */
function processDirectory(_x3, _x4, _x5, _x6) {
  return _processDirectory.apply(this, arguments);
}
/**
 * Walks a directory by retrieving all the directories and files
 * in the given path, then walking all those sub directories, then
 * all sub directories of those sub directories, etc. The end result
 * will be the entire tree, including all descendents, for the
 * target directory.
 * @param {string} directoryPath Directory to traverse.
 * @param {number} [maximumPaths] The maximum number of paths to
 *  process before the method gives up and throws an exception.
 *  Default value is 5000.
 * @param {boolean} [includeDescendents] If true, the method will walk
 *  descendent directories. If false, the method will only include files
 *  immediately below the given directory. Default value is true.
 */
function _processDirectory() {
  _processDirectory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(directoryPath, directories, files, errors) {
    var contents, totalSize;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          contents = false;
          totalSize = 0;
          _context3.prev = 2;
          _context3.next = 5;
          return fs.readdir(directoryPath);
        case 5:
          contents = _context3.sent;
          _context3.next = 11;
          break;
        case 8:
          _context3.prev = 8;
          _context3.t0 = _context3["catch"](2);
          errors.push(_context3.t0);
        case 11:
          if (!contents) {
            _context3.next = 14;
            break;
          }
          _context3.next = 14;
          return concurrentLoop(contents, /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(childPath) {
              var fullChildPath, childStat;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    fullChildPath = Path.join(directoryPath, childPath);
                    if (isTempPath(fullChildPath)) {
                      _context2.next = 13;
                      break;
                    }
                    _context2.prev = 2;
                    _context2.next = 5;
                    return fs.stat(fullChildPath);
                  case 5:
                    childStat = _context2.sent;
                    _context2.next = 12;
                    break;
                  case 8:
                    _context2.prev = 8;
                    _context2.t0 = _context2["catch"](2);
                    errors.push(_context2.t0);
                    return _context2.abrupt("return");
                  case 12:
                    if (childStat.isDirectory()) {
                      directories.push({
                        path: fullChildPath
                      });
                    } else if (childStat.isFile()) {
                      files.push({
                        path: fullChildPath,
                        size: childStat.size
                      });
                      totalSize += childStat.size;
                    }
                  case 13:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, null, [[2, 8]]);
            }));
            return function (_x10) {
              return _ref2.apply(this, arguments);
            };
          }());
        case 14:
          return _context3.abrupt("return", totalSize);
        case 15:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[2, 8]]);
  }));
  return _processDirectory.apply(this, arguments);
}
function walkDirectory(_x7) {
  return _walkDirectory.apply(this, arguments);
}
/**
 * Creates a "thread"-specific lock on a given ID. Other threads requesting
 * a lock on the same ID won't be able to run unless there are no other
 * threads holding the lock. Once a lock is obtained, the given callback is
 * invoked; the lock will be released when the callback has finished
 * executing. The method itself returns a promise, which will resolve once
 * the callback has completed.
 * @param {string} lockId ID for which an exclusive lock will be obtained.
 * @param {function} callback Invoked when the lock has been obtained. The
 *  lock will be released when the callback has finished executing. The callback
 *  can return a Promise, and the method will wait until the Promise resolves
 *  before releasing the lock.
 * @returns {Promise} Resolves after a lock has been obtained and the given
 *  callback has finished executing.
 */
function _walkDirectory() {
  _walkDirectory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(directoryPath) {
    var maximumPaths,
      includeDescendents,
      processDirectories,
      allDirectories,
      allFiles,
      allErrors,
      walkedTotalSize,
      _processDirectories$s,
      toProcess,
      directories,
      _args4 = arguments;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          maximumPaths = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 5000;
          includeDescendents = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : true;
          processDirectories = [{
            path: directoryPath
          }];
          allDirectories = [];
          allFiles = [];
          allErrors = [];
          walkedTotalSize = 0; // this algorithm avoids recursion to prevent overflows. Instead,
          // use a stack to keep track of directories to process.
        case 7:
          if (!(processDirectories.length > 0)) {
            _context4.next = 20;
            break;
          }
          _processDirectories$s = processDirectories.shift(), toProcess = _processDirectories$s.path;
          directories = []; // eslint-disable-next-line no-await-in-loop
          _context4.t0 = walkedTotalSize;
          _context4.next = 13;
          return processDirectory(toProcess, directories, allFiles, allErrors);
        case 13:
          walkedTotalSize = _context4.t0 += _context4.sent;
          allDirectories = allDirectories.concat(directories);
          if (includeDescendents) {
            processDirectories = processDirectories.concat(directories);
          }
          if (!(allDirectories.length + allFiles.length > maximumPaths)) {
            _context4.next = 18;
            break;
          }
          throw new UploadError("Walked directory exceeded the maximum number of ".concat(maximumPaths, " paths"), ErrorCodes.TOO_LARGE);
        case 18:
          _context4.next = 7;
          break;
        case 20:
          return _context4.abrupt("return", {
            directories: allDirectories,
            files: allFiles,
            errors: allErrors,
            totalSize: walkedTotalSize
          });
        case 21:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _walkDirectory.apply(this, arguments);
}
function getLock(_x8, _x9) {
  return _getLock.apply(this, arguments);
}
function _getLock() {
  _getLock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(lockId, callback) {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          return _context5.abrupt("return", lock.acquire(lockId, callback));
        case 1:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _getLock.apply(this, arguments);
}
module.exports = {
  concurrentLoop: concurrentLoop,
  getAverage: getAverage,
  trimRight: trimRight,
  trimLeft: trimLeft,
  joinUrlPath: joinUrlPath,
  trimContentDam: trimContentDam,
  normalizePath: normalizePath,
  isTempPath: isTempPath,
  walkDirectory: walkDirectory,
  getLock: getLock
};