"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var DirectBinaryUploadOptions = require('./direct-binary-upload-options');
var _require = require('./constants'),
  DefaultValues = _require.DefaultValues,
  RegularExpressions = _require.RegularExpressions;
var UploadError = require('./upload-error');
var ErrorCodes = require('./error-codes');

/**
 * Options specific to a file system upload. Also supports all options defined by
 * DirectBinaryUploadOptions.
 */
var FileSystemUploadOptions = /*#__PURE__*/function (_DirectBinaryUploadOp) {
  _inherits(FileSystemUploadOptions, _DirectBinaryUploadOp);
  var _super = _createSuper(FileSystemUploadOptions);
  function FileSystemUploadOptions() {
    var _this;
    _classCallCheck(this, FileSystemUploadOptions);
    _this = _super.call(this);
    _this.replaceValue = '-';
    _this.folderNodeProcessor = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", name.replace(RegularExpressions.INVALID_FOLDER_CHARACTERS_REGEX, _this.replaceValue).toLowerCase());
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    _this.assetNodeProcessor = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", name.replace(RegularExpressions.INVALID_ASSET_CHARACTERS_REGEX, _this.replaceValue));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    return _this;
  }

  /**
   * Creates a new FileSystemUploadOptions instance that will have the same options
   * as an existing options instance.
   * @param {DirectBinaryUploadOptions} uploadOptions Options whose value should
   *  be copied.
   */
  _createClass(FileSystemUploadOptions, [{
    key: "withMaxUploadFiles",
    value:
    /**
     * Sets the maximum number of files that can be uploaded using the module at one time. If
     * the total number of files exceeds this number then the library will throw an exception
     * with code TOO_LARGE.
     * @param {*} maxFileCount
     * @returns {FileSystemUploadOptions} The current options instance. Allows for chaining.
     */
    function withMaxUploadFiles(maxFileCount) {
      this.options.maxUploadFiles = maxFileCount;
      return this;
    }

    /**
     * Sets a value indicating whether or not the process should upload all descendent
     * directories and files within the given directory.
     * @param {boolean} deepUpload True if the upload should be deep, false otherwise.
     * @returns {FileSystemUploadOptions} The current options instance. Allows for chaining.
     */
  }, {
    key: "withDeepUpload",
    value: function withDeepUpload(deepUpload) {
      this.options.deepUpload = deepUpload;
      return this;
    }

    /**
     * Sets a function that will be called before a folder is created in AEM. The given function
     * argument will be given the name of the folder as it appears on the file system, and should
     * return the name to use as the folder's node name in AEM.
     *
     * Regardless of the return value of the processor function, certain illegal characters will
     * always be removed from the node name. These include <code>/\.[]*:|</code>. The characters
     * will be replaced by the value set using withInvalidCharacterReplaceValue().
     *
     * The original folder name will be used as the AEM folder's title.
     *
     * The default behavior is to replace characters <code>%;#,+?^{}"</code> (and whitespace) with
     * the value set using withInvalidCharacterReplaceValue(), and to convert the name to lower
     * case.
     * @param {function} processorFunction Function that will receive a single argument - the
     *  name of a folder. Should return a Promise that resolves with the node name to use for
     *  the folder.
     * @returns {FileSystemUploadOptions} The current options instance. Allows for chaining.
     */
  }, {
    key: "withFolderNodeNameProcessor",
    value: function withFolderNodeNameProcessor(processorFunction) {
      this.folderNodeProcessor = processorFunction;
      return this;
    }

    /**
     * Sets a function that will be called before an asset is created in AEM. The given function
     * argument will be given the name of the asset as it appears on the file system, and should
     * return the name to use as the asset's node name in AEM.
     *
     * Regardless of the return value of the processor function, certain illegal characters will
     * always be removed from the node name. These include <code>/\.[]*:|</code>. The characters
     * will be replaced by the value set using withInvalidCharacterReplaceValue().
     *
     * The default behavior is to replace characters <code>#%{}?&</code> with the
     * value set using withInvalidCharacterReplaceValue().
     * @param {function} processorFunction Function that will receive a single argument - the
     *  name of an asset. Should return a Promise that resolves with the node name to use for
     *  the asset.
     * @returns {FileSystemUploadOptions} The current options instance. Allows for chaining.
     */
  }, {
    key: "withAssetNodeNameProcessor",
    value: function withAssetNodeNameProcessor(processorFunction) {
      this.assetNodeProcessor = processorFunction;
      return this;
    }

    /**
     * The value to use when replacing invalid characters in folder or asset node names.
     * @param {string} replaceValue Value to use when replacing invalid node name characters.
     *  Must not contain any of the invalid characters.
     * @returns {FileSystemUploadOptions} The current options instance. Allows for chaining.
     */
  }, {
    key: "withInvalidCharacterReplaceValue",
    value: function withInvalidCharacterReplaceValue(replaceValue) {
      if (RegularExpressions.INVALID_CHARACTERS_REGEX.test(replaceValue)) {
        throw new UploadError('Invalid character replace value contains invalid characters', ErrorCodes.INVALID_OPTIONS);
      }
      this.replaceValue = replaceValue;
      return this;
    }

    /**
     * Upload file options that will be applied to each file that is uploaded as
     * part of the file system upload. Most options that can be passed as part of
     * a single file upload using DirectBinaryUploadOptions.withUploadFiles() are
     * valid. The only exceptions are "fileName", "fileSize", "filePath", and
     * "blob", which will be ignored.
     *
     * @param {object} options Upload file options to apply to each file.
     */
  }, {
    key: "withUploadFileOptions",
    value: function withUploadFileOptions(options) {
      this.uploadFileOptions = options;
      return this;
    }

    /**
     * Retrieves the maximum number of files that the module can upload in a single upload
     * request.
     *
     * @returns {number} Maximum file count.
     */
  }, {
    key: "getMaxUploadFiles",
    value: function getMaxUploadFiles() {
      return this.options.maxUploadFiles || DefaultValues.MAX_FILE_UPLOAD;
    }

    /**
     * Retrieves a value indicating whether the process should upload all descendent
     * directories and files within the given directory.
     * @returns {boolean} True for a deep upload, false otherwise.
     */
  }, {
    key: "getDeepUpload",
    value: function getDeepUpload() {
      return !!this.options.deepUpload;
    }

    /**
     * Retrieves the function to use to get the node name for a folder to create
     * in AEM.
     * @returns {function} Function that expects a single folder name argument, and
     *  returns a Promise that will be resolved with a node name.
     */
  }, {
    key: "getFolderNodeNameProcessor",
    value: function getFolderNodeNameProcessor() {
      return this.folderNodeProcessor;
    }

    /**
     * Retrieves the function to use to get the node name for an asset to create
     * in AEM.
     * @returns {function} Function that expects a single asset name argument, and
     *  returns a Promise that will be resolved with a node name.
     */
  }, {
    key: "getAssetNodeNameProcessor",
    value: function getAssetNodeNameProcessor() {
      return this.assetNodeProcessor;
    }

    /**
     * Retrieves the value to use when replacing invalid characters in node names.
     * @returns {string} Replace value.
     */
  }, {
    key: "getInvalidCharacterReplaceValue",
    value: function getInvalidCharacterReplaceValue() {
      return this.replaceValue;
    }

    /**
     * Retrieves the upload file options that will be applied to each file uploaded
     * through the module.
     *
     * @returns {object} Upload file options.
     */
  }, {
    key: "getUploadFileOptions",
    value: function getUploadFileOptions() {
      return this.uploadFileOptions || {};
    }
  }], [{
    key: "fromOptions",
    value: function fromOptions(uploadOptions) {
      var newOptions = new FileSystemUploadOptions();
      newOptions.options = _objectSpread({}, uploadOptions.options);
      newOptions.controller = uploadOptions.controller;
      if (uploadOptions.proxy) {
        newOptions.proxy = uploadOptions.proxy;
      }
      if (typeof uploadOptions.replaceValue === 'string') {
        newOptions.replaceValue = uploadOptions.replaceValue;
      }
      if (typeof uploadOptions.folderNodeProcessor === 'function') {
        newOptions.folderNodeProcessor = uploadOptions.folderNodeProcessor;
      }
      if (typeof uploadOptions.assetNodeProcessor === 'function') {
        newOptions.assetNodeProcessor = uploadOptions.assetNodeProcessor;
      }
      if (_typeof(uploadOptions.uploadFileOptions) === 'object') {
        newOptions.uploadFileOptions = uploadOptions.uploadFileOptions;
      }
      return newOptions;
    }
  }]);
  return FileSystemUploadOptions;
}(DirectBinaryUploadOptions);
module.exports = FileSystemUploadOptions;