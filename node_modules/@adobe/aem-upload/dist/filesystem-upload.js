"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var Path = require('path');
var fs = require('./fs-promise');
var DirectBinaryUpload = require('./direct-binary-upload');
var DirectBinaryUploadProcess = require('./direct-binary-upload-process');
var FileSystemUploadOptions = require('./filesystem-upload-options');
var _require = require('./utils'),
  trimContentDam = _require.trimContentDam,
  walkDirectory = _require.walkDirectory,
  isTempPath = _require.isTempPath;
var _require2 = require('./http-utils'),
  submitRequest = _require2.submitRequest;
var UploadError = require('./upload-error');
var ErrorCodes = require('./error-codes');
var UploadResult = require('./upload-result');
var _require3 = require('./filesystem-upload-utils'),
  isDeepUpload = _require3.isDeepUpload,
  getMaxFileCount = _require3.getMaxFileCount;
var FileSystemUploadItemManager = require('./filesystem-upload-item-manager');
var CreateDirectoryResult = require('./create-directory-result');
var _require4 = require('./constants'),
  HttpMethods = _require4.HttpMethods;

/**
 * Uploads one or more files from the local file system to a target AEM instance using direct
 * binary access.
 */
var FileSystemUpload = /*#__PURE__*/function (_DirectBinaryUpload) {
  _inherits(FileSystemUpload, _DirectBinaryUpload);
  var _super = _createSuper(FileSystemUpload);
  function FileSystemUpload() {
    _classCallCheck(this, FileSystemUpload);
    return _super.apply(this, arguments);
  }
  _createClass(FileSystemUpload, [{
    key: "upload",
    value:
    /**
     * Retrieves information from the local file system for a list of files, creates a new directory
     * in AEM, then uploads each of the local files to the new directory using direct binary access.
     *
     * @param {import('./direct-binary-upload-options')} options Controls how the upload process
     *  behaves.
     * @param {Array<string>} localPaths List of local paths to upload. If a path is a directory
     *  then its files will be retrieved and added to the upload.
     * @returns {Promise} Will be resolved when all the files have been uploaded. The data
     *  passed in successful resolution will be an UploadResult as JSON.
     */
    function () {
      var _upload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, localPaths) {
        var fileSystemUploadOptions, uploadOptions, uploadResult, _yield$this$getUpload, directories, files, errors, totalSize, uploadFiles, fileUploadOptions, uploadProcess;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              fileSystemUploadOptions = FileSystemUploadOptions.fromOptions(options);
              uploadOptions = this.getOptions();
              uploadResult = new UploadResult(uploadOptions, fileSystemUploadOptions);
              _context.next = 5;
              return this.createTargetFolder(fileSystemUploadOptions, uploadResult);
            case 5:
              _context.next = 7;
              return this.getUploadInformation(fileSystemUploadOptions, localPaths);
            case 7:
              _yield$this$getUpload = _context.sent;
              directories = _yield$this$getUpload.directories;
              files = _yield$this$getUpload.files;
              errors = _yield$this$getUpload.errors;
              totalSize = _yield$this$getUpload.totalSize;
              this.logInfo("From ".concat(localPaths.length, " paths, filesystem upload compiled upload of ").concat(directories.length, " directories, ").concat(files.length, " files, with a total size of ").concat(totalSize, ". Encountered ").concat(errors.length, " filesystem-related errors."));
              uploadFiles = this.convertToUploadFilesWithUrl(fileSystemUploadOptions, files); // initiate the upload process
              fileUploadOptions = FileSystemUploadOptions.fromOptions(fileSystemUploadOptions).withUploadFiles(uploadFiles);
              uploadProcess = new DirectBinaryUploadProcess(this.getOptions(), fileUploadOptions);
              this.beforeUploadProcess(uploadProcess, directories.length);
              _context.next = 19;
              return this.createUploadDirectories(fileSystemUploadOptions, uploadResult, directories);
            case 19:
              if (!uploadFiles.length) {
                _context.next = 25;
                break;
              }
              this.logInfo("Uploading ".concat(uploadFiles.length, " files"));
              _context.next = 23;
              return this.executeUploadProcess(uploadProcess, uploadResult);
            case 23:
              _context.next = 26;
              break;
            case 25:
              this.logInfo('No files found in provided paths, skipping upload.');
            case 26:
              this.afterUploadProcess(uploadProcess, uploadResult, directories.length);

              // we have a list of multiple results (for each directory upload). Merge all those
              // into a single result that contains metrics for the overall upload of all
              // directories and files.
              return _context.abrupt("return", uploadResult.toJSON());
            case 28:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function upload(_x, _x2) {
        return _upload.apply(this, arguments);
      }
      return upload;
    }()
    /**
     * Converts a list of FileSystemUploadAsset instances to a list of UploadFile items, ready
     * for use in upload options.
     * @param {FileSystemUploadOptions} options Options for the upload.
     * @param {Array<import('./filesystem-upload-asset')>} files List of FileSystemUploadAsset
     *  instances.
     * @returns {Array} List of files ready for use with DirectBinaryUploadOptions.withUploadFiles().
     */
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "convertToUploadFiles",
    value: function convertToUploadFiles(options, files) {
      var fileList = [];
      files.forEach(function (file) {
        fileList.push(_objectSpread(_objectSpread({}, options.getUploadFileOptions()), {}, {
          fileName: file.getRemoteNodeName(),
          filePath: file.getLocalPath(),
          fileSize: file.getSize()
        }));
      });
      return fileList;
    }

    /**
     * Converts a list of FileSystemUploadAsset instances to a list of UploadFile items, ready
     * for use in upload options. The file options generated by this method will include a
     * "fileUrl" property instead of a "fileName" property.
     * @param {import('./direct-binary-upload-options')} options Options controlling the upload.
     * @param {Array<import('./filesystem-upload-asset')>} files List of FileSystemUploadAsset
     *  instances.
     * @returns {Array} List of files ready for use with DirectBinaryUploadOptions.withUploadFiles().
     */
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "convertToUploadFilesWithUrl",
    value: function convertToUploadFilesWithUrl(options, files) {
      var fileList = [];
      files.forEach(function (file) {
        fileList.push(_objectSpread(_objectSpread({}, options.getUploadFileOptions()), {}, {
          fileUrl: "".concat(file.getParentRemoteUrl(), "/").concat(encodeURIComponent(file.getRemoteNodeName())),
          filePath: file.getLocalPath(),
          fileSize: file.getSize()
        }));
      });
      return fileList;
    }

    /**
     * Iterates over a list of local paths provided to the upload. If a path is a file, it will
     * be added to a master list of all paths to upload. If a path is a directory, the method
     * will (recursively) iterate over all descendent directories and files in the path and add
     * them to the master list of paths to upload.
     * @param {import('./direct-binary-upload-options')} options Controls how the upload behaves.
     *  Will be used to determine the maximum number of files to upload.
     * @param {Array<string>} localPaths List of local paths to iterate.
     * @returns {object} Aggregated information about all paths to be included in the upload. Has
     *  the following elements:
     *  * {Array} directories: List of full paths to all directories included in the upload.
     *  * {Array} files: List of full paths to all files included in the upload.
     *  * {Array} errors: List of any errors that occurred during processing, which may result in
     *    some paths being excluded from the final result.
     *  * {number} totalSize: Size, in bytes, of all files included in the upload.
     *  * {boolean} isDirectory: True if the path is a directory, false otherwise.
     */
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "getUploadInformation",
    value: function () {
      var _getUploadInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options, localPaths) {
        var allFiles, allDirectories, allErrors, allTotalSize, isDeep, i, currPath, stat, _yield$walkDirectory, directories, files, errors, totalSize, itemManager, subDirectories, directoryIndex, dirPath, subAssets, assetIndex, _files$assetIndex, filePath, fileSize, _itemManager, maxFileCount;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              allFiles = [];
              allDirectories = [];
              allErrors = [];
              allTotalSize = 0;
              isDeep = isDeepUpload(options);
              i = 0;
            case 6:
              if (!(i < localPaths.length)) {
                _context2.next = 79;
                break;
              }
              currPath = localPaths[i];
              if (isTempPath(currPath)) {
                _context2.next = 73;
                break;
              }
              stat = false;
              _context2.prev = 10;
              _context2.next = 13;
              return fs.stat(localPaths[i]);
            case 13:
              stat = _context2.sent;
              _context2.next = 20;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](10);
              allErrors.push(_context2.t0);
              // eslint-disable-next-line no-continue
              return _context2.abrupt("continue", 76);
            case 20:
              if (!stat.isDirectory()) {
                _context2.next = 65;
                break;
              }
              _context2.next = 23;
              return walkDirectory(currPath, getMaxFileCount(options), isDeep);
            case 23:
              _yield$walkDirectory = _context2.sent;
              directories = _yield$walkDirectory.directories;
              files = _yield$walkDirectory.files;
              errors = _yield$walkDirectory.errors;
              totalSize = _yield$walkDirectory.totalSize;
              itemManager = new FileSystemUploadItemManager(options, currPath, !isDeep);
              if (!isDeep) {
                _context2.next = 48;
                break;
              }
              _context2.t1 = allDirectories;
              _context2.next = 33;
              return itemManager.getDirectory(currPath);
            case 33:
              _context2.t2 = _context2.sent;
              _context2.t1.push.call(_context2.t1, _context2.t2);
              subDirectories = [];
              directoryIndex = 0;
            case 37:
              if (!(directoryIndex < directories.length)) {
                _context2.next = 47;
                break;
              }
              dirPath = directories[directoryIndex].path; // eslint-disable-next-line no-await-in-loop
              _context2.t3 = subDirectories;
              _context2.next = 42;
              return itemManager.getDirectory(dirPath);
            case 42:
              _context2.t4 = _context2.sent;
              _context2.t3.push.call(_context2.t3, _context2.t4);
            case 44:
              directoryIndex += 1;
              _context2.next = 37;
              break;
            case 47:
              allDirectories = allDirectories.concat(subDirectories);
            case 48:
              subAssets = [];
              assetIndex = 0;
            case 50:
              if (!(assetIndex < files.length)) {
                _context2.next = 60;
                break;
              }
              _files$assetIndex = files[assetIndex], filePath = _files$assetIndex.path, fileSize = _files$assetIndex.size; // eslint-disable-next-line no-await-in-loop
              _context2.t5 = subAssets;
              _context2.next = 55;
              return itemManager.getAsset(filePath, fileSize);
            case 55:
              _context2.t6 = _context2.sent;
              _context2.t5.push.call(_context2.t5, _context2.t6);
            case 57:
              assetIndex += 1;
              _context2.next = 50;
              break;
            case 60:
              allFiles = allFiles.concat(subAssets);
              allErrors = allErrors.concat(errors);
              allTotalSize += totalSize;
              _context2.next = 73;
              break;
            case 65:
              if (!stat.isFile()) {
                _context2.next = 73;
                break;
              }
              _itemManager = new FileSystemUploadItemManager(options, currPath); // eslint-disable-next-line no-await-in-loop
              _context2.t7 = allFiles;
              _context2.next = 70;
              return _itemManager.getAsset(currPath, stat.size);
            case 70:
              _context2.t8 = _context2.sent;
              _context2.t7.push.call(_context2.t7, _context2.t8);
              allTotalSize += stat.size;
            case 73:
              maxFileCount = getMaxFileCount(options);
              if (!(allFiles.length > maxFileCount)) {
                _context2.next = 76;
                break;
              }
              throw new UploadError("File system upload has exceeded maximum of ".concat(maxFileCount, " allowed files"), ErrorCodes.TOO_LARGE);
            case 76:
              i += 1;
              _context2.next = 6;
              break;
            case 79:
              return _context2.abrupt("return", {
                directories: allDirectories,
                files: allFiles,
                errors: allErrors,
                totalSize: allTotalSize
              });
            case 80:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[10, 16]]);
      }));
      function getUploadInformation(_x3, _x4) {
        return _getUploadInformation.apply(this, arguments);
      }
      return getUploadInformation;
    }()
    /**
     * Given path information for a local path upload, creates all the directories required to
     * complete the upload. The method will iterate all of the paths in the given information,
     * create the path itself if it's a directory, and create all of of descendent directories.
     * @param {import('./direct-binary-upload-options')} options Target folder information used
     *  to determine location where directories should be created.
     * @param {UploadResult} uploadResult Statistics about the upload process.
     * @param {Array} directories An array of FileSystemUploadDirectory instances for the
     *  directories to be created.
     */
  }, {
    key: "createUploadDirectories",
    value: function () {
      var _createUploadDirectories = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options, uploadResult, directories) {
        var i;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              i = 0;
            case 1:
              if (!(i < directories.length)) {
                _context3.next = 7;
                break;
              }
              _context3.next = 4;
              return this.createAemFolderFromFileSystemInfo(options, uploadResult, directories[i]);
            case 4:
              i += 1;
              _context3.next = 1;
              break;
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function createUploadDirectories(_x5, _x6, _x7) {
        return _createUploadDirectories.apply(this, arguments);
      }
      return createUploadDirectories;
    }()
    /**
     * Creates the target folder from upload options and all of its parents if they do not already
     * exist.
     * @param {import('./direct-binary-upload-options')} options Options controlling how the upload
     *  process behaves.
     * @param {UploadResult} uploadResult Various statistics about the upload operation.
     * @returns {Promise} Will be resolved if the folders are created successfully, otherwise will be
     *  rejected with an error.
     */
  }, {
    key: "createTargetFolder",
    value: function () {
      var _createTargetFolder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, uploadResult) {
        var targetFolder, trimmedFolder, currPath, paths, i;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              targetFolder = options.getTargetFolderPath();
              trimmedFolder = trimContentDam(targetFolder);
              if (!trimmedFolder) {
                _context4.next = 13;
                break;
              }
              currPath = '/content/dam';
              paths = String(trimmedFolder).split('/').filter(function (e) {
                return e.length;
              });
              i = 0;
            case 6:
              if (!(i < paths.length)) {
                _context4.next = 13;
                break;
              }
              currPath += "/".concat(paths[i]);
              // eslint-disable-next-line no-await-in-loop
              _context4.next = 10;
              return this.createAemFolder(options, uploadResult, currPath);
            case 10:
              i += 1;
              _context4.next = 6;
              break;
            case 13:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function createTargetFolder(_x8, _x9) {
        return _createTargetFolder.apply(this, arguments);
      }
      return createTargetFolder;
    }()
    /**
     * Creates a folder in AEM if it does not already exist.
     *
     * @param {import('./direct-binary-upload-options')} options Options controlling how the upload
     *  process behaves.
     * @param {UploadResult} uploadResult Statistics about the upload process.
     * @param {FileSystemUploadDirectory} uploadDirectory Information about the directory
     *  to be created. The instance's remote URL will be used for creation.
     * @returns {Promise} Will be resolved if the folder is created successfully, otherwise will be
     *  rejected with an error.
     */
  }, {
    key: "createAemFolderFromFileSystemInfo",
    value: function () {
      var _createAemFolderFromFileSystemInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options, uploadResult, uploadDirectory) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this.createAemFolder(options, uploadResult, uploadDirectory.getRemotePath(), uploadDirectory.getName()));
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function createAemFolderFromFileSystemInfo(_x10, _x11, _x12) {
        return _createAemFolderFromFileSystemInfo.apply(this, arguments);
      }
      return createAemFolderFromFileSystemInfo;
    }()
    /**
     * Creates a folder in AEM if it does not already exist.
     *
     * @param {import('./direct-binary-upload-options')} options Options controlling how the upload
     *  process behaves.
     * @param {UploadResult} uploadResult Statistics about the upload process.
     * @param {string} [folderPath] If specified, the path of the folder to create. If not specified,
     *  the target folder in the provided options will be used.
     * @param {string} [folderTitle] If specified, the value to use as the title of the folder. If not
     *  specified then the value will be derived from the folder's path.
     * @returns {Promise} Will be resolved if the folder is created successfully, otherwise will be
     *  rejected with an error.
     */
  }, {
    key: "createAemFolder",
    value: function () {
      var _createAemFolder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options, uploadResult) {
        var folderPath,
          folderTitle,
          targetFolder,
          trimmedFolder,
          folderName,
          createResult,
          createUrl,
          _options$getHttpOptio,
          _options$getHttpOptio2,
          optionHeaders,
          requestOptions,
          response,
          uploadError,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              folderPath = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : '';
              folderTitle = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : '';
              targetFolder = folderPath || options.getTargetFolderPath();
              trimmedFolder = trimContentDam(targetFolder);
              if (!trimmedFolder) {
                _context6.next = 32;
                break;
              }
              folderName = folderTitle || Path.basename(trimmedFolder);
              createResult = new CreateDirectoryResult(this.getOptions(), options, targetFolder, folderName);
              _context6.prev = 7;
              this.logInfo("Creating AEM directory ".concat(folderPath, " with title '").concat(folderTitle, "'"));
              createUrl = "".concat(options.getUrlPrefix(), "/api/assets").concat(encodeURI(trimmedFolder));
              _options$getHttpOptio = options.getHttpOptions(), _options$getHttpOptio2 = _options$getHttpOptio.headers, optionHeaders = _options$getHttpOptio2 === void 0 ? {} : _options$getHttpOptio2;
              requestOptions = _objectSpread(_objectSpread({}, options.getHttpOptions()), {}, {
                headers: _objectSpread(_objectSpread({}, optionHeaders), {}, {
                  'Content-Type': 'application/json'
                }),
                method: HttpMethods.POST,
                body: JSON.stringify({
                  class: 'assetFolder',
                  properties: {
                    'jcr:title': folderName
                  }
                })
              });
              _context6.next = 14;
              return submitRequest(createUrl, requestOptions);
            case 14:
              response = _context6.sent;
              if (response.ok) {
                _context6.next = 17;
                break;
              }
              throw UploadError.fromError({
                response: response,
                stack: new Error().stack
              });
            case 17:
              createResult.setCreateResponse(response);
              this.logInfo("AEM folder '".concat(targetFolder, "' is created"));
              this.emit('foldercreated', {
                folderName: folderName,
                targetParent: Path.dirname(targetFolder).replaceAll(/\\/g, '/'),
                targetFolder: targetFolder
              });
              _context6.next = 31;
              break;
            case 22:
              _context6.prev = 22;
              _context6.t0 = _context6["catch"](7);
              uploadError = UploadError.fromError(_context6.t0);
              createResult.setCreateError(uploadError);
              if (!(uploadError.code === ErrorCodes.ALREADY_EXISTS)) {
                _context6.next = 30;
                break;
              }
              this.logInfo("AEM folder '".concat(targetFolder, "' already exists"));
              _context6.next = 31;
              break;
            case 30:
              throw uploadError;
            case 31:
              uploadResult.addCreateDirectoryResult(createResult);
            case 32:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[7, 22]]);
      }));
      function createAemFolder(_x13, _x14) {
        return _createAemFolder.apply(this, arguments);
      }
      return createAemFolder;
    }()
  }]);
  return FileSystemUpload;
}(DirectBinaryUpload);
module.exports = FileSystemUpload;