"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var fs = require('fs');
var Path = require('path');
var UploadOptionsBase = require('./upload-options-base');
var UploadError = require('./upload-error');
var ErrorCodes = require('./error-codes');

/**
 * Analyzes the given file options and determines if there is sufficient information
 * to upload the file. If insufficient, the method will throw an exception.
 *
 * @param {object} options Information about the file to upload.
 */
function ensureRequiredOptions(options) {
  if (!options.fileName && !options.fileUrl || !options.fileSize && options.fileSize !== 0 || !options.filePath && (!options.blob || !options.blob.slice)) {
    throw new UploadError('UploadFile missing required fields. Must have one of fileName or fileUrl, fileSize, and either filePath or blob', ErrorCodes.INVALID_OPTIONS);
  }
}

/**
 * Represents a file to upload, as provided in upload options. Includes information like the file's
 * name and size. Also provide capabilities for reading chunks of the file.
 */
var UploadFile = /*#__PURE__*/function (_UploadOptionsBase) {
  _inherits(UploadFile, _UploadOptionsBase);
  var _super = _createSuper(UploadFile);
  /**
   * Constructs a new instance based on the given information.
   *
   * @param {object} options Options as provided when the direct binary upload was instantiated.
   * @param {DirectBinaryUploadOptions} uploadOptions  Options as provided when the upload was
   *   initiated.
   * @param {object} fileOptions Options for the specific file, as provided in the upload options.
   * @param {string} fileOptions.fileName The name of the file as it should appear when uploaded.
   * @param {number} fileOptions.fileSize Total size of the file to upload, in bytes.
   * @param {string} [fileOptions.filePath] Full path to the local filesystem file to upload.
   *   Either this value or "blob" must be provided.
   * @param {Array} [fileOptions.blob] Full binary content of the file to upload. Either this
   *   value or "filePath" must be provided.
   */
  function UploadFile(options, uploadOptions, fileOptions) {
    var _this;
    _classCallCheck(this, UploadFile);
    _this = _super.call(this, options, uploadOptions);
    _this.fileOptions = fileOptions;
    return _this;
  }

  /**
   * Retrieves the full URL of the file, based on the given upload options
   * and file options.
   *
   * @returns {string} URL of the file.
   */
  _createClass(UploadFile, [{
    key: "getFileUrl",
    value: function getFileUrl() {
      ensureRequiredOptions(this.fileOptions);
      var fileUrl = this.fileOptions.fileUrl;
      var fileName = this.fileOptions.fileName;
      if (!fileUrl) {
        fileUrl = "".concat(this.getUploadOptions().getUrl(), "/").concat(encodeURIComponent(fileName));
      }
      return fileUrl;
    }

    /**
     * Retrieves the name of the file as provided in the options.
     *
     * @returns {string} Name of the file.
     */
  }, {
    key: "getFileName",
    value: function getFileName() {
      ensureRequiredOptions(this.fileOptions);
      var name = Path.basename(new URL(this.getFileUrl()).pathname);
      return decodeURIComponent(name);
    }

    /**
     * Retrieves the size of the file, in bytes, as provided in the options.
     *
     * @returns {number} Size of the file.
     */
  }, {
    key: "getFileSize",
    value: function getFileSize() {
      ensureRequiredOptions(this.fileOptions);
      return this.fileOptions.fileSize;
    }

    /**
     * Retrieves a value indicating whether or not a new version of the file should be
     * created if it already exists.
     *
     * @returns {boolean} True if a new version should be created, false otherwise.
     */
  }, {
    key: "shouldCreateNewVersion",
    value: function shouldCreateNewVersion() {
      ensureRequiredOptions(this.fileOptions);
      return !!this.fileOptions.createVersion;
    }

    /**
     * Retrieves the label of the new version should one need to be created.
     *
     * @returns {string} A version label.
     */
  }, {
    key: "getVersionLabel",
    value: function getVersionLabel() {
      ensureRequiredOptions(this.fileOptions);
      return this.fileOptions.versionLabel;
    }

    /**
     * Retrieves the comment of the new version should one need to be created.
     *
     * @returns {string} A version comment.
     */
  }, {
    key: "getVersionComment",
    value: function getVersionComment() {
      ensureRequiredOptions(this.fileOptions);
      return this.fileOptions.versionComment;
    }

    /**
     * Retrieves a value indicating whether or not the asset should be replaced if
     * it already exists.
     *
     * @returns {boolean} True if the asset should be replaced, false otherwise.
     */
  }, {
    key: "shouldReplace",
    value: function shouldReplace() {
      ensureRequiredOptions(this.fileOptions);
      return !!this.fileOptions.replace;
    }

    /**
     * Retrieves a chunk of the file for processing, based on the start and end
     * offset. The type of value returned by this method will vary depending on
     * the file options that were provided to the constructor.
     * @param {number} start Byte offset, inclusive, within the file where the chunk will begin.
     * @param {number} end Byte offset, exclusive, within the file where the chunk will end.
     * @returns {Readable|Array} If "filePath" was provided in the file options when constructed,
     *  then the return value will be a Readable stream. If "blob" was provided in the file options
     *  then the return value will be an Array.
     */
  }, {
    key: "getFileChunk",
    value: function getFileChunk(start, end) {
      ensureRequiredOptions(this.fileOptions);
      var _this$fileOptions = this.fileOptions,
        filePath = _this$fileOptions.filePath,
        blob = _this$fileOptions.blob;
      if (filePath) {
        return fs.createReadStream(filePath, {
          start: start,
          end: end
        });
      }
      return blob.slice(start, end);
    }

    /**
     * Retrieves the headers that should be included with each part upload request.
     * @returns {object} Simple object whose names are header names, and whose values
     *  are header values.
     */
  }, {
    key: "getPartHeaders",
    value: function getPartHeaders() {
      ensureRequiredOptions(this.fileOptions);
      var _this$fileOptions$par = this.fileOptions.partHeaders,
        partHeaders = _this$fileOptions$par === void 0 ? {} : _this$fileOptions$par;
      return partHeaders;
    }

    /**
     * Converts the class instance into a simple object representation.
     *
     * @returns {object} Simplified view of the class instance.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this$fileOptions2 = this.fileOptions,
        fileSize = _this$fileOptions2.fileSize,
        filePath = _this$fileOptions2.filePath;
      var json = {
        fileUrl: this.getFileUrl(),
        fileSize: fileSize
      };
      if (this.shouldCreateNewVersion()) {
        json.createVersion = true;
      }
      if (this.getVersionComment()) {
        json.versionComment = this.getVersionComment();
      }
      if (this.getVersionLabel()) {
        json.versionLabel = this.getVersionLabel();
      }
      if (this.shouldReplace()) {
        json.replace = this.shouldReplace();
      }
      if (filePath) {
        json.filePath = filePath;
      }
      if (Object.keys(this.getPartHeaders()).length) {
        json.multipartHeaders = this.getPartHeaders();
      }
      return json;
    }
  }]);
  return UploadFile;
}(UploadOptionsBase);
module.exports = UploadFile;