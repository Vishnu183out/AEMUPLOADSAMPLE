"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/*
Copyright 2019 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

var errorCodes = require('./error-codes');

/**
 * Concatenates to message values together if both are provided.
 *
 * @param {string} overallMessage Will be prepended to specificMessage, delimited with a colon, if
 *  supplied.
 * @param {string} specificMessage Will be concatenated with overallMessage, if supplied. Otherwise
 *  the return value of the method will be specificMessage as-is.
 * @returns {string} A message value.
 */
function getFullMessage(overallMessage, specificMessage) {
  if (overallMessage) {
    return "".concat(overallMessage, ": ").concat(specificMessage);
  }
  return specificMessage;
}

/**
 * Custom Error class containing additional information specific to the upload process. This
 * primarily consists of an error code, which can be used by consumers to provide more specific
 * information about the nature of an error.
 */
var UploadError = /*#__PURE__*/function (_Error) {
  _inherits(UploadError, _Error);
  var _super = _createSuper(UploadError);
  /**
   * Constructs a new instance containing the provided information.
   *
   * @param {string} message The message that will appear with the Error instance.
   * @param {string} code The code indicating the specific type of error.
   * @param {string} [innerStack] Additional stack information if the UploadError instance
   *  originated from another Error.
   */
  function UploadError(message, code) {
    var _this;
    var innerStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    _classCallCheck(this, UploadError);
    _this = _super.call(this, message);
    _this.code = code;
    _this.innerStack = innerStack;
    _this.uploadError = true;
    return _this;
  }

  /**
   * Retrieves the error code representing the specific type of error. See ErrorCodes for more
   * information.
   *
   * @returns {string} An error code value.
   */
  _createClass(UploadError, [{
    key: "getCode",
    value: function getCode() {
      return this.code;
    }

    /**
     * Retrieves the upload error's status as an HTTP status code.
     *
     * @returns {number} An HTTP status code.
     */
  }, {
    key: "getHttpStatusCode",
    value: function getHttpStatusCode() {
      var code = this.getCode();
      if (code === errorCodes.ALREADY_EXISTS) {
        return 409;
      }
      if (code === errorCodes.FORBIDDEN) {
        return 403;
      }
      if (code === errorCodes.INVALID_OPTIONS) {
        return 400;
      }
      if (code === errorCodes.NOT_AUTHORIZED) {
        return 401;
      }
      if (code === errorCodes.NOT_FOUND) {
        return 404;
      }
      if (code === errorCodes.TOO_LARGE) {
        return 413;
      }
      if (code === errorCodes.NOT_SUPPORTED) {
        return 501;
      }
      return 500;
    }

    /**
     * Retrieves a message describing the error.
     *
     * @returns {string} The error's message.
     */
  }, {
    key: "getMessage",
    value: function getMessage() {
      return this.message;
    }

    /**
     * Retrieves the inner stack of the error, as provided to the constructor.
     *
     * @returns {string} The error's inner stack.
     */
  }, {
    key: "getInnerStack",
    value: function getInnerStack() {
      return this.innerStack;
    }

    /**
     * Converts the error instance into a simplified object form.
     *
     * @returns {object} Simple object representation of the error.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        message: this.message,
        code: this.code
      };
      if (this.innerStack) {
        json.innerStack = this.innerStack;
      }
      return json;
    }

    /**
     * Converts the error to a string, which will be a stringified version of the error's toJSON()
     * method.
     *
     * @returns {string} String representation of the error.
     */
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this);
    }
  }], [{
    key: "fromError",
    value:
    /**
     * Constructs a new UploadError instance out of a given error message. The method will attempt
     * to create the most specific type of error it can based on what it receives.
     *
     * @param {*} error Object from which to create the UploadError instance. Can be several things,
     *  including an UploadError instance, an error as thrown by axios, a string, or another Error
     *  instance.
     * @param {string} errorMessage Will appear in the error's "message" value.
     * @returns {UploadError} An upload error instance.
     */
    function fromError(error) {
      var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var message = error.message,
        code = error.code,
        uploadError = error.uploadError,
        response = error.response,
        stack = error.stack;
      if (uploadError) {
        return error;
      }
      if (response) {
        var status = response.status;
        var httpCode = errorCodes.UNKNOWN;
        if (status === 409) {
          httpCode = errorCodes.ALREADY_EXISTS;
        } else if (status === 403) {
          httpCode = errorCodes.FORBIDDEN;
        } else if (status === 400) {
          httpCode = errorCodes.INVALID_OPTIONS;
        } else if (status === 401) {
          httpCode = errorCodes.NOT_AUTHORIZED;
        } else if (status === 404) {
          httpCode = errorCodes.NOT_FOUND;
        } else if (status === 501) {
          httpCode = errorCodes.NOT_SUPPORTED;
        }
        return new UploadError("Request failed with status code ".concat(status), httpCode, stack);
      }
      if (message && code) {
        return new UploadError(getFullMessage(errorMessage, message), code, stack);
      }
      if (message) {
        return new UploadError(getFullMessage(errorMessage, message), errorCodes.UNKNOWN, stack);
      }
      if (typeof error === 'string') {
        return new UploadError(getFullMessage(errorMessage, error), errorCodes.UNKNOWN);
      }
      try {
        return new UploadError(getFullMessage(errorMessage, JSON.stringify(error)), errorCodes.UNKNOWN, stack);
      } catch (e) {
        return new UploadError(getFullMessage(errorMessage, error), errorCodes.UNKNOWN, stack);
      }
    }
  }]);
  return UploadError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
module.exports = UploadError;