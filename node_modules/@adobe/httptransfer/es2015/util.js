/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use strict';

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.symbol.match-all.js");
require("core-js/modules/es.aggregate-error.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.global-this.js");
require("core-js/modules/es.json.stringify.js");
require("core-js/modules/es.math.acosh.js");
require("core-js/modules/es.math.hypot.js");
require("core-js/modules/es.object.define-getter.js");
require("core-js/modules/es.object.define-setter.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.from-entries.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.object.lookup-getter.js");
require("core-js/modules/es.object.lookup-setter.js");
require("core-js/modules/es.object.values.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.all-settled.js");
require("core-js/modules/es.promise.any.js");
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/es.reflect.to-string-tag.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.string.match-all.js");
require("core-js/modules/es.string.pad-end.js");
require("core-js/modules/es.string.pad-start.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.replace-all.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.string.trim-end.js");
require("core-js/modules/es.string.trim-start.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.int16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.uint8-clamped-array.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.from.js");
require("core-js/modules/es.typed-array.of.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/web.queue-microtask.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/web.url-search-params.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const {
  sep,
  dirname: filePathDirname,
  basename: filePathBasename
} = require("path");
const fs = require("fs");
const validUrl = require("valid-url");
const {
  HttpStreamError
} = require("./error");

/**
 * Get the file stats (asynchronously)
 * 
 * @param {String} path File path
 * @returns {fs.Stats} File stats
 */
function getFileStats(path) {
  return new Promise((resolve, reject) => {
    fs.stat(path, (err, stats) => {
      if (err) {
        reject(err);
      } else {
        resolve(stats);
      }
    });
  });
}

/**
 * Async function to open a read stream. Resolves on open event (asynchronously).
 *
 * @param {String} path Path to file to open
 * @param {Object} options Options
 */
function createReadStream(path, options) {
  return new Promise((resolve, reject) => {
    const readStream = fs.createReadStream(path, options);
    readStream.on('open', () => {
      resolve(readStream);
    });
    const errorCallback = error => {
      readStream.removeListener('error', errorCallback);
      reject(error);
    };
    readStream.on('error', errorCallback);
  });
}

/**
 * Async function to open a write stream. Resolves on open event (asynchronously).
 *
 * @param {String} path Path to file to open
 * @param {Object} options Options
 */
function createWriteStream(path, options) {
  return new Promise((resolve, reject) => {
    const writeStream = fs.createWriteStream(path, options);
    writeStream.on('open', () => {
      resolve(writeStream);
    });
    const errorCallback = error => {
      // remove itself to prevent any future callbacks
      writeStream.removeListener('error', errorCallback);
      reject(error);
    };
    writeStream.on('error', errorCallback);
  });
}

/**
 * Check if the given value is a http/https url
 * 
 * @param {*} value Value to check 
 * @returns {Boolean} True if the value is a http/https url
 */
function isValidWebUrl(value) {
  if (value instanceof URL) {
    return value.protocol === "https:" || value.protocol === "http:";
  } else if (typeof value === "string") {
    return validUrl.isWebUri(value);
  } else {
    return false;
  }
}

/**
 * Check if the provided URL has a file protocol
 * 
 * @param {URL|string} url URI to review
 * @returns {Boolean} True if the URL has a file protocol
 */
function isFileProtocol(url) {
  return url && new URL(url).protocol === 'file:';
}

/**
 * Check if value is a positive number
 * 
 * @param {Number} value Value to check
 * @returns {Boolean} True if value is a positive number
 */
function isPositiveNumber(value) {
  return Number.isFinite(value) && value > 0;
}

/**
 * Converts the content of a readable Stream into a Buffer
 * instance. WARNING: this method will read the entirety of
 * the stream into memory; use with extreme caution.
 *
 * @param {String} method HTTP method
 * @param {String} url URL requested
 * @param {Number} status HTTP status code of response
 * @param {ReadableStream} stream Stream to convert.
 * @param {number} totalSize Total size of the stream.
 * @returns {Promise<Buffer>} Contents of the stream in a
 *  Buffer.
 */
function streamToBuffer(_x, _x2, _x3, _x4, _x5) {
  return _streamToBuffer.apply(this, arguments);
}
/**
 * Ensures that all path separators in a given path are forward
 * slashes. The method will replace any backward slashes with
 * forward slashes.
 *
 * @param {String} path Path to be processed.
 * @returns {String} Path whose separators are forward slashes.
 */
function _streamToBuffer() {
  _streamToBuffer = _asyncToGenerator(function* (method, url, status, stream, totalSize) {
    return new Promise((resolve, reject) => {
      const buffer = Buffer.allocUnsafe(totalSize);
      let bufferOffset = 0;
      stream.once('error', err => {
        reject(new HttpStreamError(method, url, status, err));
      });
      stream.once('end', () => {
        if (bufferOffset !== totalSize) {
          reject(new HttpStreamError(method, url, status, `Unexpected number of bytes read from stream. Expected ${totalSize} but got ${bufferOffset}.`));
          return;
        }
        resolve(buffer);
      });
      stream.on('data', chunk => {
        chunk.copy(buffer, bufferOffset, 0);
        bufferOffset += chunk.length;
      });
    });
  });
  return _streamToBuffer.apply(this, arguments);
}
function ensureForwardSlashes(path) {
  return path.replaceAll(/\\/g, '/');
}

/**
 * Retrieves the parent directory path of a given file path.
 * The separators in the returned path will always be forward
 * slashes, regardless of the operating system.
 *
 * @param {String} path Path to be processed.
 * @returns {String} Path whose separators are forward slashes.
 */
function urlPathDirname(path) {
  return ensureForwardSlashes(filePathDirname(path));
}

/**
 * @typedef {Object} PathInformation Information about the URL's path.
 * @property {string} path Full path from the URL.
 * @property {string} name Name of the item from the URL's path.
 * @property {string} parentPath Full path of the item's parent.
 *
 * Converts one of several potential URL values to its path.
 *
 * For example:
 *
 * If the value is a file URL (i.e. begins with file://), then the method
 * will return the URL's pathname. The method takes into account windows-style
 * paths, which might be preceeded with a leading forward slash. In addition,
 * the path will have the correct path separators, depending on the operating
 * system (i.e. backslash for windows, forward slash for posix). The path
 * will have also been URI decoded.
 *
 * Otherwise the value is assumed to be an HTTP URL, and the URL's URI decoded
 * pathname is returned.
 * @param {URL|string} path Value whose path should be retrieved.
 * @returns {PathInformation} Information about the URL's path.
 */
function urlToPath(path) {
  const url = new URL(path);
  let urlPath = decodeURIComponent(url.pathname);
  let parentPath = urlPathDirname(urlPath);
  const name = filePathBasename(urlPath);
  if (url.protocol === "file:") {
    // windows paths will have a forward slash followed by
    // the drive letter. strip off the leading forward slash
    // if it appears to be a windows path (i.e. starts with "/C:/")
    if (/^\/[a-zA-Z]:\//g.exec(urlPath)) {
      urlPath = urlPath.substr(1);
    }
    urlPath = urlPath.replace(/\//g, sep);
    parentPath = filePathDirname(urlPath);
  }
  return {
    path: urlPath,
    name,
    parentPath
  };
}
module.exports = {
  getFileStats,
  createReadStream,
  createWriteStream,
  isValidWebUrl,
  isFileProtocol,
  isPositiveNumber,
  streamToBuffer,
  urlPathDirname,
  urlToPath
};