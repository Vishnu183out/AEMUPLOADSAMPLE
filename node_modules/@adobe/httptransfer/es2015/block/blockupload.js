/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use strict';

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.symbol.match-all.js");
require("core-js/modules/es.aggregate-error.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.global-this.js");
require("core-js/modules/es.json.stringify.js");
require("core-js/modules/es.math.acosh.js");
require("core-js/modules/es.math.hypot.js");
require("core-js/modules/es.object.define-getter.js");
require("core-js/modules/es.object.define-setter.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.from-entries.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.object.lookup-getter.js");
require("core-js/modules/es.object.lookup-setter.js");
require("core-js/modules/es.object.values.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.all-settled.js");
require("core-js/modules/es.promise.any.js");
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/es.reflect.to-string-tag.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.string.match-all.js");
require("core-js/modules/es.string.pad-end.js");
require("core-js/modules/es.string.pad-start.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.replace-all.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.string.trim-end.js");
require("core-js/modules/es.string.trim-start.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.int16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.uint8-clamped-array.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.from.js");
require("core-js/modules/es.typed-array.of.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/web.queue-microtask.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/web.url-search-params.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
const fileUrl = require("file-url");
const {
  Asset
} = require("../asset/asset");
const {
  TransferAsset
} = require("../asset/transferasset");
const {
  AssetMetadata
} = require("../asset/assetmetadata");
const {
  TransferController,
  TransferEvents
} = require("../controller/transfercontroller");
const {
  CreateTransferParts
} = require("../functions/transferpartscreate");
const {
  JoinTransferParts
} = require("../functions/transferpartsjoin");
const {
  FailUnsupportedAssets
} = require("../functions/failunsupportedassets");
const {
  CloseFiles
} = require("../functions/closefiles");
const {
  MapConcurrent
} = require("../generator/mapconcurrent");
const {
  Transfer
} = require("../functions/transfer");
const {
  executePipeline,
  Pipeline
} = require("../generator/pipeline");
const {
  RandomFileAccess
} = require("../randomfileaccess");
const EventEmitter = require("events");
const UploadError = require("./upload-error");
const {
  FilterFailedAssets
} = require("../functions/filterfailedassets");
const {
  IllegalArgumentError
} = require("../error");
const {
  getFileStats
} = require('../util');
const {
  AssetMultipart
} = require("../asset/assetmultipart");
const {
  BlockRequestGenerator
} = require("../asset/blockrequestgenerator");
const DEFAULT_MAX_CONCURRENCY = 8;
// Default part size is 10mb
const DEFAULT_PART_SIZE = 10 * 1024 * 1024;

/**
 * Generate Block upload transfer assets
 * mantaining generator pattern in case nui in future
 * starts supporting batch upload of renditions
 * 
 * @generator
 * @param {BlockUploadOptions} options 
 * @yields {TransferAsset} Transfer asset
 */
function generateBlockUploadTransfer(_x) {
  return _generateBlockUploadTransfer.apply(this, arguments);
}
function _generateBlockUploadTransfer() {
  _generateBlockUploadTransfer = _wrapAsyncGenerator(function* (options) {
    console.log(`Generating block upload transfer parts`);
    const expectedLength = options.uploadFiles && (options.uploadFiles.length || options.uploadFiles.size);
    let assetCounter = 0;
    for (const uploadFile of options.uploadFiles) {
      if (!uploadFile.filePath) {
        throw new IllegalArgumentError('filePath must be provided in uploadFiles', JSON.stringify(uploadFile));
      }
      const sourceUrl = fileUrl(uploadFile.filePath);
      // assetTarget is a required field in block library
      let assetTarget;
      if (typeof uploadFile.fileUrl === "object" && Array.isArray(uploadFile.fileUrl) && uploadFile.fileUrl.length > 0) {
        console.log("Multiple uploads to run");
        assetTarget = uploadFile.fileUrl[0];
      } else {
        console.log("Single upload to run");
        assetTarget = uploadFile.fileUrl;
      }
      const targetUrl = new URL(assetTarget);
      const source = new Asset(sourceUrl);
      const target = new Asset(targetUrl, options.headers, uploadFile.multipartHeaders);
      if (!uploadFile.fileSize) {
        console.log("Getting transfer asset size from file to upload");
        const {
          size
        } = yield _awaitAsyncGenerator(getFileStats(uploadFile.filePath));
        uploadFile.fileSize = size;
      }
      const contentType = options.headers && options.headers['content-type'];
      console.log(`Transfer asset to upload is of content type ${contentType} and size ${uploadFile.fileSize} bytes`);
      const transferAsset = new TransferAsset(source, target, {
        acceptRanges: true,
        metadata: new AssetMetadata(uploadFile.filePath, contentType, uploadFile.fileSize)
      });
      const uploadURIs = uploadFile.fileUrl;
      const maxPartSize = uploadFile.maxPartSize;
      const minPartSize = uploadFile.minPartSize || Math.min(10, maxPartSize); // maxPartSize must be defined

      if (typeof uploadURIs === "object" && Array.isArray(uploadURIs) && uploadURIs.length > 0) {
        console.log(`Upload target is multipart ( ${uploadURIs.length} parts), min part size: ${minPartSize}, max part size: ${maxPartSize}`);
        transferAsset.multipartTarget = new AssetMultipart(uploadURIs, minPartSize, maxPartSize, transferAsset.target.multipartHeaders);
      }
      assetCounter++;
      console.log(`Generated upload transfer asset ${assetCounter} of ${expectedLength}`);
      yield transferAsset;
    }
    console.log(`Generated ${assetCounter} upload transfer assets (files to upload: ${expectedLength})`);
  });
  return _generateBlockUploadTransfer.apply(this, arguments);
}
class BlockUpload extends EventEmitter {
  /**
   * @typedef {Object} UploadFile
   * @property {String} fileUrl AEM url where to upload the file
   * @property {Number} fileSize Size of the file to upload
   * @property {String} filePath Path on the local disk to upload
   * @property {Blob} [blob] Browser blob to upload (instead of fileUrl)
   * @property {Boolean} [createVersion=false] Create version on duplicates
   * @property {String} [versionLabel] Version label to apply to the created/updated file
   * @property {String} [versionComment] Version comment to apply to the created/updated file
   * @property {Boolean} [replace=false] True if the existing file should be replaced
   */
  /**
   * @typedef {Object} BlockUploadOptions
   * @property {UploadFile[]} uploadFiles List of files that will be uploaded to the target URL. 
   * @property {*} headers HTTP headers that will be included in each request sent to AEM
   * @property {Boolean} concurrent If true, multiple files in the supplied list of upload files will transfer simultaneously. If false, only one file will transfer at a time, and the next file will not begin transferring until the current file finishes. (currently not in use)
   * @property {Number} maxConcurrent Maximum number of concurrent HTTP requests that are allowed. If set to 1, only one chunk will transfer at a time, and the next chunk will not begin transferring until the current file finishes.
   * @property {Number} [preferredPartSize] Preferred part size
   */

  /**
   * Creates a new block upload instance
   */
  constructor() {
    super();
    this.errorEvents = null;
  }

  /**
   * Create a a block upload controller, which emits events
   * on file (upload) start, file (upload) progress, file (upload) end
   * and file (upload) error.
   * @returns {TransferController} Transfer controller (for upload)
   */
  createBlockUploadController() {
    const controller = new TransferController();
    this.errorEvents = [];
    controller.on(TransferEvents.TRANSFER, transferEvent => {
      console.log("Block upload: block upload controller starting part upload");
      this.emit("transferPart", transferEvent.transferAsset.eventData);
    });
    controller.on(TransferEvents.JOIN_TRANSFER_PARTS, transferEvent => {
      this.emit("fileprogress", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
        transferred: transferEvent.props.transferBytes
      }));
    });
    controller.on(TransferEvents.AFTER_TRANSFER, transferEvent => {
      console.log("Block upload: block upload controller finishing part upload");
      this.emit("aftertransfer", transferEvent.transferAsset.eventData);
    });
    controller.on(TransferEvents.ERROR, transferEvent => {
      console.log(`Error during block upload: ${transferEvent.error}`);
      if (transferEvent.props.firstError) {
        this.errorEvents.push(transferEvent);
        this.emit("fileerror", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
          errors: [UploadError.fromError(transferEvent.error)]
        }));
      }
    });
    return controller;
  }

  /**
  * Removes all listeners for events 
  * `CREATE_TRANSFER_PARTS`, `JOIN_TRANSFER_PARTS`,
  * `AFTER_JOIN_TRANSFER_PARTS` and `ERROR`
  * from a block upload controller
  * @param {TransferController} controller a block download controller
  */
  finalizeBlockUploadController(controller) {
    if (!controller) {
      return;
    }
    if (this.errorEvents) {
      this.errorEvents = null;
    }
    try {
      controller.removeAllListeners(TransferEvents.CREATE_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.JOIN_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.AFTER_JOIN_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.ERROR);
    } catch (err) {
      console.log(`Failed to remove event listeners from block upload controller: ${err}`);
    }
  }

  /**
   * Upload files
   * 
   * @param {BlockUploadOptions} options AEM upload options
   */
  uploadFiles(options = {}) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const preferredPartSize = options.preferredPartSize || DEFAULT_PART_SIZE;
      const maxConcurrent = options.maxConcurrent || DEFAULT_MAX_CONCURRENCY;

      // Build and execute pipeline
      const controller = _this.createBlockUploadController();
      const randomFileAccess = new RandomFileAccess();
      const requestGenerator = new BlockRequestGenerator();
      try {
        const pipeline = new Pipeline(new FailUnsupportedAssets(), new CreateTransferParts({
          preferredPartSize
        }), new MapConcurrent(new Transfer(randomFileAccess, requestGenerator, options), {
          maxConcurrent
        }), new JoinTransferParts(), new CloseFiles(randomFileAccess));
        pipeline.setFilterFunction(new FilterFailedAssets());
        console.log("Block upload: executing block upload pipeline");
        yield executePipeline(pipeline, generateBlockUploadTransfer(options), controller);
        console.log("Block upload: finished executing block upload pipeline");
        if (_this.errorEvents && _this.errorEvents.length > 0) {
          // delete file (not needed - as AEM won't commit the blob in case of error)
          // throw the first emitted error
          console.log(`Errors encountered during block upload (${_this.errorEvents.length} total error(s))`);
          throw _this.errorEvents[0].error;
        }
      } finally {
        if (controller) {
          _this.finalizeBlockUploadController(controller);
        }
        if (randomFileAccess) {
          yield randomFileAccess.close();
          console.log("Block upload: closed random file accessor");
        }
      }
    })();
  }
}
module.exports = {
  BlockUpload
};