/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use strict';

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.symbol.match-all.js");
require("core-js/modules/es.aggregate-error.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.global-this.js");
require("core-js/modules/es.json.stringify.js");
require("core-js/modules/es.math.acosh.js");
require("core-js/modules/es.math.hypot.js");
require("core-js/modules/es.object.define-getter.js");
require("core-js/modules/es.object.define-setter.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.from-entries.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.object.lookup-getter.js");
require("core-js/modules/es.object.lookup-setter.js");
require("core-js/modules/es.object.values.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.all-settled.js");
require("core-js/modules/es.promise.any.js");
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/es.reflect.to-string-tag.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.string.match-all.js");
require("core-js/modules/es.string.pad-end.js");
require("core-js/modules/es.string.pad-start.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.replace-all.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.string.trim-end.js");
require("core-js/modules/es.string.trim-start.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.int16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.uint8-clamped-array.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.from.js");
require("core-js/modules/es.typed-array.of.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/web.queue-microtask.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/web.url-search-params.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
const EventEmitter = require('events');
const fileUrl = require('file-url');
const DownloadError = require('./download-error');
const {
  Asset
} = require('../asset/asset');
const {
  TransferAsset
} = require('../asset/transferasset');
const {
  AssetMetadata
} = require('../asset/assetmetadata');
const {
  TransferController,
  TransferEvents
} = require('../controller/transfercontroller');
const {
  CreateTransferParts
} = require('../functions/transferpartscreate');
const {
  JoinTransferParts
} = require('../functions/transferpartsjoin');
const {
  CloseFiles
} = require('../functions/closefiles');
const {
  MapConcurrent
} = require('../generator/mapconcurrent');
const {
  Transfer
} = require('../functions/transfer');
const {
  executePipeline,
  Pipeline
} = require('../generator/pipeline');
const {
  RandomFileAccess
} = require('../randomfileaccess');
const {
  FilterFailedAssets
} = require('../functions/filterfailedassets');
const {
  GetAssetMetadata
} = require('../functions/getassetmetadata');
const {
  BlockRequestGenerator
} = require('../asset/blockrequestgenerator');

/**
 * Generate AEM download transfer assets
 * 
 * @generator
 * @param {AEMDownloadOptions} options 
 * @yields {TransferAsset} Transfer asset
 */
function generateBlockDownloadTransfer(_x) {
  return _generateBlockDownloadTransfer.apply(this, arguments);
}
/**
 * Provide a single file download process which is allowed to run in parallel
 */
function _generateBlockDownloadTransfer() {
  _generateBlockDownloadTransfer = _wrapAsyncGenerator(function* (options) {
    console.log(`Generating block download transfer parts`);
    const expectedLength = options.downloadFiles && (options.downloadFiles.length || options.downloadFiles.size);
    let assetCounter = 0;
    for (const downloadFile of options.downloadFiles) {
      const sourceUrl = new URL(downloadFile.fileUrl);
      const targetPath = fileUrl(downloadFile.filePath);
      const source = new Asset(sourceUrl, options.headers);
      const target = new Asset(targetPath);
      const transferAsset = new TransferAsset(source, target, {
        acceptRanges: true,
        metadata: new AssetMetadata(downloadFile.filePath, downloadFile.contentType, downloadFile.fileSize)
      });
      assetCounter++;
      console.log(`Generated download transfer asset ${assetCounter} of ${expectedLength}`);
      yield transferAsset;
    }
    console.log(`Generated ${assetCounter} download transfer assets (files to download: ${expectedLength})`);
  });
  return _generateBlockDownloadTransfer.apply(this, arguments);
}
const DEFAULT_MAX_CONCURRENCY = 8;
// Default part size is 10mb
const DEFAULT_PART_SIZE = 10 * 1024 * 1024;

/**
 * @typedef {Object} DownloadFile
 * @property {String} fileUrl AEM url of file to download
 * @property {String} filePath Path on the local disk where to download
 * @property {Number} fileSize Size of the file being downloaded
 */

class BlockDownload extends EventEmitter {
  /**
   * @typedef {Object} BlockDownloadOptions
   * @property {Integer} maxConcurrent Maximum number of concurrent HTTP requests that are allowed (deafult is 8)
   * @property {DownloadFile[]} downloadFiles Files that will be downloaded.
   * @property {Boolean} retryEnabled If true, retries will be attempted for failed parts
   * @property {Number} [preferredPartSize] Preferred part size
   * @property {Number} [retryCount] Retry count (default is 5)
   */

  /**
   * Constructs a new block download (event emitter) instance
   */
  constructor() {
    super();
    this.errorEvents = null;
  }

  /**
   * Create a a block download controller, which emits events
   * on file (download) start, file (download) progress, file (download) end
   * and file (download) error.
   * @returns {TransferController} Transfer controller
   */
  createBlockDownloadController() {
    const controller = new TransferController();
    this.errorEvents = [];
    controller.on(TransferEvents.CREATE_TRANSFER_PARTS, transferEvent => {
      console.log("Block download: block download controller starting file download");
      this.emit("filestart", transferEvent.transferAsset.eventData);
    });
    controller.on(TransferEvents.JOIN_TRANSFER_PARTS, transferEvent => {
      this.emit("fileprogress", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
        transferred: transferEvent.props.transferBytes
      }));
    });
    controller.on(TransferEvents.AFTER_JOIN_TRANSFER_PARTS, transferEvent => {
      console.log("Block download: block download controller finishing file download");
      this.emit("fileend", transferEvent.transferAsset.eventData);
    });
    controller.on(TransferEvents.ERROR, transferEvent => {
      console.log(`Error during block download: ${transferEvent.error}`);
      this.errorEvents.push(transferEvent);
      if (transferEvent.props.firstError) {
        this.emit("fileerror", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
          errors: [DownloadError.fromError(transferEvent.error)]
        }));
      }
    });
    return controller;
  }

  /**
   * Removes all listeners for events 
   * `CREATE_TRANSFER_PARTS`, `JOIN_TRANSFER_PARTS`,
   * `AFTER_JOIN_TRANSFER_PARTS` and `ERROR`
   * from a block download controller
   * @param {TransferController} controller a block download controller
   */
  finalizeController(controller) {
    if (!controller) {
      return;
    }
    if (this.errorEvents) {
      this.errorEvents = null;
    }
    try {
      controller.removeAllListeners(TransferEvents.CREATE_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.JOIN_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.AFTER_JOIN_TRANSFER_PARTS);
      controller.removeAllListeners(TransferEvents.ERROR);
    } catch (err) {
      console.log(`Failed to remove event listeners from block download controller: ${err}`);
    }
  }

  /**
   * Download files to local disk
   * Throws the first unrecoverable error if unsuccessful, all others are logged
   * 
   * @param {BlockDownloadOptions} options Block download options
   */
  downloadFiles(options = {}) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const preferredPartSize = options.preferredPartSize || DEFAULT_PART_SIZE;
      const maxConcurrent = options.maxConcurrent || DEFAULT_MAX_CONCURRENCY;

      // Build and execute pipeline
      const controller = _this.createBlockDownloadController();
      const randomFileAccess = new RandomFileAccess();
      const requestGenerator = new BlockRequestGenerator();
      try {
        const pipeline = new Pipeline(new GetAssetMetadata(options), new CreateTransferParts({
          preferredPartSize
        }), new MapConcurrent(new Transfer(randomFileAccess, requestGenerator, options), {
          maxConcurrent
        }), new JoinTransferParts(), new CloseFiles(randomFileAccess));
        pipeline.setFilterFunction(new FilterFailedAssets());
        console.log("Block download: executing block download pipeline");
        yield executePipeline(pipeline, generateBlockDownloadTransfer(options), controller);
        console.log("Block download: finished executing block download pipeline");
        if (_this.errorEvents && _this.errorEvents.length > 0) {
          // throw the first emitted error during transfer
          console.log(`Errors encountered during block download (${_this.errorEvents.length} total error(s))`);
          throw _this.errorEvents[0].error;
        }
      } finally {
        if (controller) {
          _this.finalizeController(controller);
        }
        if (randomFileAccess) {
          yield randomFileAccess.close();
          console.log("Block download: closed random file accessor");
        }
        if (controller) {
          yield controller.cleanupFailedTransfers();
          console.log("Block download: cleaned up failed transfers");
        }
      }
    })();
  }
}
module.exports = {
  BlockDownload
};