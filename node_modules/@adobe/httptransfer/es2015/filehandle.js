/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.symbol.match-all.js");
require("core-js/modules/es.aggregate-error.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.global-this.js");
require("core-js/modules/es.json.stringify.js");
require("core-js/modules/es.math.acosh.js");
require("core-js/modules/es.math.hypot.js");
require("core-js/modules/es.object.define-getter.js");
require("core-js/modules/es.object.define-setter.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.from-entries.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.object.lookup-getter.js");
require("core-js/modules/es.object.lookup-setter.js");
require("core-js/modules/es.object.values.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.all-settled.js");
require("core-js/modules/es.promise.any.js");
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/es.reflect.to-string-tag.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.flags.js");
require("core-js/modules/es.string.match-all.js");
require("core-js/modules/es.string.pad-end.js");
require("core-js/modules/es.string.pad-start.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.replace-all.js");
require("core-js/modules/es.string.split.js");
require("core-js/modules/es.string.trim.js");
require("core-js/modules/es.string.trim-end.js");
require("core-js/modules/es.string.trim-start.js");
require("core-js/modules/es.typed-array.float32-array.js");
require("core-js/modules/es.typed-array.float64-array.js");
require("core-js/modules/es.typed-array.int8-array.js");
require("core-js/modules/es.typed-array.int16-array.js");
require("core-js/modules/es.typed-array.int32-array.js");
require("core-js/modules/es.typed-array.uint8-array.js");
require("core-js/modules/es.typed-array.uint8-clamped-array.js");
require("core-js/modules/es.typed-array.uint16-array.js");
require("core-js/modules/es.typed-array.uint32-array.js");
require("core-js/modules/es.typed-array.fill.js");
require("core-js/modules/es.typed-array.from.js");
require("core-js/modules/es.typed-array.of.js");
require("core-js/modules/es.typed-array.set.js");
require("core-js/modules/es.typed-array.sort.js");
require("core-js/modules/web.queue-microtask.js");
require("core-js/modules/web.url.js");
require("core-js/modules/web.url.to-json.js");
require("core-js/modules/web.url-search-params.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const fs = require("fs");
const logger = require("./logger");
const {
  urlToPath
} = require("./util");

/**
 * File open flags
 */
const FileFlags = {
  READONLY: "readonly",
  // Open for reading, fails if file doesn't exist
  WRITEONLY: "writeonly" // Open for writing, extend the file if size is provided
};

/**
 * Abstraction around the lower-level file descriptor.
 * 
 * This code is intended to support ES2015 through Babel, which is why it
 * is using older APIs.
 */
class FileHandle {
  /**
   * Construct a file handle
   * 
   * Recommend using `FileHandle.open` to open the actual file.
   * 
   * @param {String} path File path
   * @param {FileFlags} flags File flags
   * @param {Number} fd File descriptor
   */
  constructor(path, flags, fd) {
    /**
     * File path
     * @type {String}
     */
    this.path = path;
    /**
     * File open flags
     * @type {FileFlags}
     */
    this.flags = flags;
    /**
     * File descriptor
     */
    this.fd = fd;
  }

  /**
   * Open a file handle
   * 
   * @param {String|URL} path File path, or file:// url
   * @param {FileFlags} flags File flags to open (readonly, writeonly)
   * @returns {FileHandle} file handle
   */
  static open(path, flags) {
    return _asyncToGenerator(function* () {
      return new Promise((resolve, reject) => {
        const filePath = urlToPath(path).path;
        const openFlags = flags === FileFlags.WRITEONLY ? "w" : "r";
        fs.open(filePath, openFlags, (err, fd) => {
          if (err) {
            reject(err);
          } else {
            resolve(new FileHandle(filePath, flags, fd));
          }
        });
      });
    })();
  }

  /**
   * Close the file handle
   * 
   * @param {Object} [options] Close options
   * @param {Boolean} [options.silent] If true, any errors are logged instead of thrown
   */
  close(options) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const self = _this;
      const silent = options && options.silent;
      return new Promise((resolve, reject) => {
        fs.close(self.fd, err => {
          if (err && silent) {
            logger.warn(`Unable to close file handle of ${self.path}`, err);
          } else if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    })();
  }

  /**
   * Truncate/extend a file to the given length
   * 
   * @param {Number} length New length
   */
  truncate(length) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const self = _this2;
      return new Promise((resolve, reject) => {
        fs.ftruncate(self.fd, length, err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    })();
  }

  /**
   * Read data from file
   * 
   * @param {Buffer} buffer Buffer where data will be written to
   * @param {Number} offset Offset in the buffer where to start writing
   * @param {Number} length Number of bytes to read
   * @param {Number} position Position in the file where to begin reading
   * @returns {Numbers} Number of bytes actually read
   */
  read(buffer, offset, length, position) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const self = _this3;
      return new Promise((resolve, reject) => {
        fs.read(self.fd, buffer, offset, length, position, (err, bytesRead) => {
          if (err) {
            reject(err);
          } else {
            resolve(bytesRead);
          }
        });
      });
    })();
  }

  /**
   * Write data to file
   * 
   * @param {Buffer} buffer Buffer where data will be read from
   * @param {Number} offset Offset in the buffer where to start reading
   * @param {Number} length Number of bytes to write
   * @param {Number} position Position in the file where to begin writing
   * @returns {Numbers} Number of bytes actually written
   */
  write(buffer, offset, length, position) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      const self = _this4;
      return new Promise((resolve, reject) => {
        fs.write(self.fd, buffer, offset, length, position, (err, bytesWritten) => {
          if (err) {
            reject(err);
          } else {
            resolve(bytesWritten);
          }
        });
      });
    })();
  }
}
module.exports = {
  FileHandle,
  FileFlags
};