/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _asyncGeneratorDelegate(inner) { var iter = {}, waiting = !1; function pump(key, value) { return waiting = !0, value = new Promise(function (resolve) { resolve(inner[key](value)); }), { done: !1, value: new _OverloadYield(value, 1) }; } return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, iter.next = function (value) { return waiting ? (waiting = !1, value) : pump("next", value); }, "function" == typeof inner.throw && (iter.throw = function (value) { if (waiting) throw waiting = !1, value; return pump("throw", value); }), "function" == typeof inner.return && (iter.return = function (value) { return waiting ? (waiting = !1, value) : pump("return", value); }), iter; }
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
const assert = require("assert");
const {
  AsyncGeneratorFunction
} = require("./function");

/**
 * Wait for the next result
 * 
 * @param {Promise[]} pending Pending results
 * @param {Boolean} ordered True if the results should be returned in the same order as they entered
 * @returns {Object} next result
 */
function waitResult(_x, _x2) {
  return _waitResult.apply(this, arguments);
}
/**
 * Check if the next item can be part of the current batch
 * 
 * @param {AsyncGeneratorFunction} mapFunction Asynchronous generator function
 * @param {Object[]} batch Current batch of items
 * @param {Object} item Next item
 * @param {Number} maxBatchLength Maximum batch length
 * @returns {Boolean} True when the item was added to the batch
 */
function _waitResult() {
  _waitResult = _asyncToGenerator(function* (pending, ordered) {
    if (pending.length === 0) {
      throw Error("Invalid state: pending is empty");
    } else if (ordered) {
      const result = yield pending[0];
      pending.shift();
      return result;
    } else {
      // Ensure the original pending promise is returned with the value, so we know
      // which promise to delete from the pending array.
      const {
        promise,
        result
      } = yield Promise.race(pending.map(promise => Promise.resolve(promise).then(result => {
        return {
          promise,
          result
        };
      })));
      const i = pending.findIndex(pendingPromise => pendingPromise === promise);
      assert.ok(i >= 0, `Promise ${promise} -> ${result} not in pending state`);
      pending.splice(i, 1); // remove completed item
      return result;
    }
  });
  return _waitResult.apply(this, arguments);
}
function checkAddBatch(mapFunction, batch, item, maxBatchLength) {
  if (batch.length === 0) {
    return true;
  } else if (batch.length >= maxBatchLength) {
    return false;
  } else if (mapFunction.checkAddBatch && !mapFunction.checkAddBatch(batch, item)) {
    return false;
  } else {
    return true;
  }
}

/**
 * Execute the function on a batch of values
 * 
 * @param {AsyncGeneratorFunction} mapFunction Asynchronous generator function
 * @param {Object[]} values Batch of values
 * @param {Object[]} args Additional arguments
 * @returns {Object[]} Batch of results
 */
function executeBatch(_x3, _x4, _x5) {
  return _executeBatch.apply(this, arguments);
}
/**
 * @callback CheckAddBatchCallback
 * @param {Object[]} batch Current batch of items (guaranteed to not be empty)
 * @param {Object} item Item to add to the batch
 * @returns {Boolean} True if the item can be added to the batch
 */
/**
 * @typedef {Object} MapConcurrentOptions
 * @property {Number} [maxBatchLength=1] Maximum batch length
 * @property {Number} [maxConcurrent=1] Maximum concurrency (defaults to no concurrency)
 * @property {Boolean} [ordered=false] Map the items out of input concurrently while keeping the results in the same order
 */
/**
 * Execute an AsyncGeneratorFunction on batches and concurrently
 * 
 * Defaults to no concurrency, and no batch creation, which results in the provided function to be executed on each item
 * one at a time.
 * 
 * Increasing `maxBatchLength` will result in the function to be executed on `maxBatchLength` number of items. A function
 * can limit batches to only "similar" items by implementing the `checkAddBatch(batch, item)` callback function.
 * 
 * Increasing `maxConcurrent` will result in items to be executed concurrently by invoking the providing function concurrently,
 * this works together with `maxBatchLength` where concurrent batches can be processed.
 * 
 * By default the mapping is unordered, so the first result is returned once available. Setting `ordered` to `true` will 
 * ensure the results are in the same order as the input.
 */
function _executeBatch() {
  _executeBatch = _asyncToGenerator(function* (mapFunction, values, args) {
    const result = [];
    var _iteratorAbruptCompletion = false;
    var _didIteratorError = false;
    var _iteratorError;
    try {
      for (var _iterator = _asyncIterator(mapFunction.execute(values, ...args)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {
        const x = _step.value;
        {
          result.push(x);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (_iteratorAbruptCompletion && _iterator.return != null) {
          yield _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return result;
  });
  return _executeBatch.apply(this, arguments);
}
class MapConcurrent extends AsyncGeneratorFunction {
  /**
   * Construct MapConcurrent
   * 
   * @param {AsyncGeneratorFunction} [mapFunction] function to map the values
   * @param {MapConcurrentOptions} [options] Map concurrent options
   */
  constructor(mapFunction, options) {
    super();
    this.mapFunction = mapFunction;
    this.maxBatchLength = Math.max(options && options.maxBatchLength || 1, 1);
    this.maxConcurrent = Math.max(options && options.maxConcurrent || 1, 1);
    this.ordered = !!(options && options.ordered);
  }

  /**
   * Execute the generator, yields the same number of results as input items
   * 
   * @generator
   * @param {Object[]|Generator||AsyncGenerator} items Items to process
   * @param {Object[]} [args] Arguments
   * @yields {Object} 
   */
  execute(items, ...args) {
    var _this = this;
    return _wrapAsyncGenerator(function* () {
      const pending = [];
      let batch = [];
      var _iteratorAbruptCompletion2 = false;
      var _didIteratorError2 = false;
      var _iteratorError2;
      try {
        for (var _iterator2 = _asyncIterator(items), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {
          const item = _step2.value;
          {
            if (checkAddBatch(_this.mapFunction, batch, item, _this.maxBatchLength)) {
              batch.push(item);
            } else {
              while (pending.length >= _this.maxConcurrent) {
                yield* _asyncGeneratorDelegate(_asyncIterator(yield _awaitAsyncGenerator(waitResult(pending, _this.ordered))), _awaitAsyncGenerator);
              }
              pending.push(executeBatch(_this.mapFunction, batch, args));
              batch = [item];
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
            yield _awaitAsyncGenerator(_iterator2.return());
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      while (batch.length > 0 || pending.length > 0) {
        // execute the remainder batch
        if (batch.length > 0 && pending.length < _this.maxConcurrent) {
          pending.push(executeBatch(_this.mapFunction, batch, args));
          batch = [];
        }

        /// wait for the remainder results
        yield* _asyncGeneratorDelegate(_asyncIterator(yield _awaitAsyncGenerator(waitResult(pending, _this.ordered))), _awaitAsyncGenerator);
      }
    })();
  }
}
module.exports = {
  MapConcurrent
};