/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
const fileUrl = require("file-url");
const {
  Asset
} = require("../asset/asset");
const {
  TransferAsset
} = require("../asset/transferasset");
const {
  AssetMetadata
} = require("../asset/assetmetadata");
const {
  TransferController,
  TransferEvents
} = require("../controller/transfercontroller");
const {
  CreateTransferParts
} = require("../functions/transferpartscreate");
const {
  JoinTransferParts
} = require("../functions/transferpartsjoin");
const {
  CloseFiles
} = require("../functions/closefiles");
const {
  MapConcurrent
} = require("../generator/mapconcurrent");
const {
  Transfer
} = require("../functions/transfer");
const {
  executePipeline,
  Pipeline
} = require("../generator/pipeline");
const {
  RandomFileAccess
} = require("../randomfileaccess");
const EventEmitter = require("events");
const UploadError = require("../block/download-error");
const {
  FilterFailedAssets
} = require("../functions/filterfailedassets");
const {
  BlockRequestGenerator
} = require("../asset/blockrequestgenerator");

/**
 * Generate AEM download transfer assets
 * 
 * @generator
 * @param {AEMDownloadOptions} options 
 * @yields {TransferAsset} Transfer asset
 */
function generateAEMDownloadTransferRecords(_x) {
  return _generateAEMDownloadTransferRecords.apply(this, arguments);
}
function _generateAEMDownloadTransferRecords() {
  _generateAEMDownloadTransferRecords = _wrapAsyncGenerator(function* (options) {
    for (const downloadFile of options.downloadFiles) {
      const sourceUrl = new URL(downloadFile.fileUrl);
      const targetUrl = fileUrl(downloadFile.filePath);
      const source = new Asset(sourceUrl, options.headers);
      const target = new Asset(targetUrl);
      const transferAsset = new TransferAsset(source, target, {
        acceptRanges: true,
        metadata: new AssetMetadata(downloadFile.filePath, undefined, downloadFile.fileSize)
      });
      yield transferAsset;
    }
  });
  return _generateAEMDownloadTransferRecords.apply(this, arguments);
}
class AEMDownload extends EventEmitter {
  /**
   * @typedef {Object} DownloadFile
   * @property {String} fileUrl AEM url of file to download
   * @property {String} filePath Path on the local disk where to download
   * @property {Number} fileSize Size of the file being downloaded
   */
  /**
   * @typedef {Object} AEMDownloadOptions
   * @property {DownloadFile[]} downloadFiles List of files that will be downloaded.
   * @property {*} headers HTTP headers that will be included in each request sent to AEM.
   * @property {Boolean} concurrent If true, multiple files in the supplied list of download files will transfer simultaneously. If false, only one file will transfer at a time, and the next file will not begin transferring until the current file finishes.
   * @property {Number} maxConcurrent Maximum number of concurrent HTTP requests that are allowed
   * @property {Number} [preferredPartSize] Preferred part size
   * @property {Object} requestOptions Options that will be passed to fetch (either node-fetch-npm or native fetch, depending on the context)
   */
  /**
   * Download files from AEM to local disk
   * 
   * @param {AEMDownloadOptions} options AEM download options
   */
  downloadFiles(options) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const preferredPartSize = options && options.preferredPartSize;
      const maxConcurrent = options && options.concurrent && options.maxConcurrent || 1;
      const requestOptions = options.requestOptions || {};
      const controller = new TransferController();
      controller.on(TransferEvents.CREATE_TRANSFER_PARTS, transferEvent => {
        _this.emit("filestart", transferEvent.transferAsset.eventData);
      });
      controller.on(TransferEvents.JOIN_TRANSFER_PARTS, transferEvent => {
        _this.emit("fileprogress", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
          transferred: transferEvent.props.transferBytes
        }));
      });
      controller.on(TransferEvents.AFTER_JOIN_TRANSFER_PARTS, transferEvent => {
        _this.emit("fileend", transferEvent.transferAsset.eventData);
      });
      controller.on(TransferEvents.ERROR, transferEvent => {
        if (transferEvent.props.firstError) {
          _this.emit("fileerror", _objectSpread(_objectSpread({}, transferEvent.transferAsset.eventData), {}, {
            errors: [UploadError.fromError(transferEvent.error)]
          }));
        }
      });
      const transferOptions = {
        retryMaxCount: 5,
        requestOptions
      };

      // Build and execute pipeline
      const randomFileAccess = new RandomFileAccess();
      const httpRequestGenerator = new BlockRequestGenerator();
      try {
        const pipeline = new Pipeline(new CreateTransferParts({
          preferredPartSize
        }), new MapConcurrent(new Transfer(randomFileAccess, httpRequestGenerator, transferOptions), {
          maxConcurrent
        }), new JoinTransferParts(), new CloseFiles(randomFileAccess));
        pipeline.setFilterFunction(new FilterFailedAssets());
        yield executePipeline(pipeline, generateAEMDownloadTransferRecords(options), controller);
      } finally {
        yield randomFileAccess.close();
      }
    })();
  }
}
module.exports = {
  AEMDownload
};