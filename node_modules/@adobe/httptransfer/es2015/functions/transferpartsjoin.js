/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
const {
  AsyncGeneratorFunction
} = require("../generator/function");
const DRange = require("drange");
const {
  TransferEvents
} = require("../controller/transfercontroller");

/**
 * Check if all parts have completed
 * 
 * @param {DRange} finishedParts Finished parts
 * @param {Number} contentLength Content length
 * @returns {Boolean} True if the parts have been completed
 */
function isComplete(finishedParts, contentLength) {
  const subRanges = finishedParts.subranges();
  return subRanges && subRanges.length === 1 && subRanges[0].low === 0 && subRanges[0].high === contentLength - 1;
}

/**
 * Complete upload/download of assets in/to AEM.
 */
class JoinTransferParts extends AsyncGeneratorFunction {
  /**
   * Construct the JoinTransferParts function.
   */
  constructor() {
    super();
    this.trackedAssets = new Map();
    this.totalTransferredBytes = 0;
  }

  /**
   * Track progress and completion
   * 
   * notifyBefore -> the transfer parts as received with progress update
   * notifyAfter  -> each transfer asset once complete before yielded
   * notifyYield  -> each transfer asset once complete after yielded
   * 
   * @param {TransferPart} transferParts Part that has transferred (or failed to)
   * @param {TransferController} controller Transfer controller
   * @returns {TransferPart} 
   */
  execute(transferParts, controller) {
    var _this = this;
    return _wrapAsyncGenerator(function* () {
      var _iteratorAbruptCompletion = false;
      var _didIteratorError = false;
      var _iteratorError;
      try {
        for (var _iterator = _asyncIterator(transferParts), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
          const transferPart = _step.value;
          {
            const transferAsset = transferPart.transferAsset;
            try {
              // find/create a record for all transferred parts
              let trackedAsset = _this.trackedAssets.get(transferAsset);
              if (!trackedAsset) {
                trackedAsset = {
                  completedRanges: new DRange()
                };
                _this.trackedAssets.set(transferAsset, trackedAsset);
              }

              // record progress
              const {
                completedRanges
              } = trackedAsset;
              completedRanges.add(transferPart.contentRange);
              _this.totalTransferredBytes += transferPart.contentRange.length;
              controller.notify(TransferEvents.JOIN_TRANSFER_PARTS, _this.name, transferPart, {
                transferBytes: completedRanges.length,
                totalTransferredBytes: _this.totalTransferredBytes
              });

              // check if the transfer has been completed
              const contentLength = transferPart.metadata.contentLength;
              if (isComplete(completedRanges, contentLength)) {
                transferAsset.transferEndTime = Date.now();
                _this.trackedAssets.delete(transferAsset);
                controller.notify(TransferEvents.AFTER_JOIN_TRANSFER_PARTS, _this.name, transferAsset);
                yield transferAsset;
              }
            } catch (error) {
              controller.notifyError(_this.name, error, transferPart);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion && _iterator.return != null) {
            yield _awaitAsyncGenerator(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    })();
  }
}
module.exports = {
  JoinTransferParts
};