/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
const logger = require("../logger");
const {
  AsyncGeneratorFunction
} = require("../generator/function");
const {
  isFileProtocol,
  streamToBuffer
} = require("../util");
const {
  issuePut,
  streamGet
} = require("../fetch");
const {
  retry
} = require("../retry");
const {
  HTTP
} = require("../constants");
const {
  TransferEvents
} = require("../controller/transfercontroller");
const MAX_MEMORY_BUFFER = 100 * 1024 * 1024;

/**
 * @callback RetryOnHttpResponseErrorCallback
 * @param {HttpResponseError} error Contains information about the request error
 * @returns {Boolean} True if the request should be retried, False otherwise
 */

/**
 * @typedef {Object} TransferOptions
 *
 * @property {Number} [timeout=3000] Optional socket timeout
 * @property {Number} [retryMaxCount] number of retry attempts, overrides retryMaxDuration
 * @property {Number} [retryMaxDuration=60000] time to retry until throwing an error (ms)
 * @property {Number} [retryInterval=100] time between retries, used by exponential backoff (ms)
 * @property {Boolean} [retryEnabled=true] retry on failure enabled
 * @property {Boolean} [retryAllErrors=false] whether or not to retry on all http error codes or just >=500
 * @property {RetryOnHttpResponseErrorCallback} [retryOnHttpResponseError=false] Optional function determining whether to retry a request based on the HttpResponseError
 * @property {Object} [requestOptions] Options that will be passed to fetch (either node-fetch-npm or native fetch, depending on the context)
 */
/**
 * Transfer parts
 */
class Transfer extends AsyncGeneratorFunction {
  /**
   * Construct a transfer function
   * 
   * @param {RandomFileAccess} randomFileAccess Random file access instance
   * @param {import('../asset/httprequestgenerator').HttpRequestGenerator} requestGenerator Used by the transfer process
   *  to control various information about the HTTP being sent.
   * @param {TransferOptions} [options] Transfer options
   */
  constructor(randomFileAccess, requestGenerator, options) {
    super();
    this.requestGenerator = requestGenerator;
    this.randomFileAccess = randomFileAccess;
    this.options = options;
  }
  /**
   * Transfer a part
   * 
   * @param {TransferPart} transferPart Part to transfer
   * @param {TransferController} controller Transfer controller
   * @returns {TransferPart} 
   */
  execute(transferParts, controller) {
    var _this = this;
    return _wrapAsyncGenerator(function* () {
      var _iteratorAbruptCompletion = false;
      var _didIteratorError = false;
      var _iteratorError;
      try {
        for (var _iterator = _asyncIterator(transferParts), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
          const transferPart = _step.value;
          {
            const {
              transferAsset
            } = transferPart;
            if (!transferAsset.transferStartTime) {
              controller.notify(TransferEvents.TRANSFER_ASSET, _this.name, transferPart);
              transferAsset.transferStartTime = Date.now();
            }
            try {
              controller.notify(TransferEvents.TRANSFER, _this.name, transferPart);
              const targetUrl = Array.isArray(transferPart.targetUrls) && transferPart.targetUrls.length === 1 && transferPart.targetUrls[0];
              const contentRanges = transferPart.contentRange.subranges();
              if (contentRanges.length !== 1) {
                throw Error(`'contentRanges' must be a single range: ${contentRanges}`);
              }
              const contentRange = contentRanges[0];
              if (contentRange.length > MAX_MEMORY_BUFFER) {
                throw Error(`'contentRange.length' too large, not supported yet: ${transferPart.source.url}`);
              }
              console.log(`Transferred content range: ${contentRange}`);
              if (isFileProtocol(transferPart.source.url) && targetUrl) {
                console.log("Source has protocol 'file'");
                const buf = yield _awaitAsyncGenerator(_this.randomFileAccess.read(transferPart.source.url, contentRange));
                if (contentRange) {
                  if (buf && buf.length) {
                    console.log(`Read file ${transferPart.source.url} for content range low ${contentRange.low}, to high ${contentRange.high}, read ${buf.length} bytes`);
                  } else {
                    console.log(`Nothing read from file for content range low ${contentRange.low}, to high ${contentRange.high}`);
                  }
                } else {
                  if (buf && buf.length) {
                    console.log(`Read file ${transferPart.source.url} (no content range), read ${buf.length} bytes`);
                  } else {
                    console.log(`Nothing read from file (no content range)`);
                  }
                }
                yield _awaitAsyncGenerator(retry( /*#__PURE__*/_asyncToGenerator(function* () {
                  const body = _this.requestGenerator.createPartHttpBody({
                    transferPart,
                    partData: buf,
                    contentRange
                  });
                  const requestOptions = _objectSpread({
                    body,
                    timeout: _this.options && _this.options.timeout,
                    headers: Object.assign(_this.requestGenerator.createPartHttpHeaders({
                      transferPart,
                      httpBody: body,
                      contentRange
                    }), transferPart.targetHeaders)
                  }, _this.options.requestOptions);
                  // to stay backwards compatible, AEMmultiPart upload supports methods `POST` instead of `PUT`
                  if (_this.options && _this.options.method) {
                    requestOptions.method = _this.options.method;
                  }
                  yield issuePut(targetUrl, requestOptions);
                }), _this.options));
              } else if (transferPart.source.blob && targetUrl) {
                console.log(`Source is blob, transferring ranges low ${contentRange.low}, to high ${contentRange.high}`);
                const blob = transferPart.source.blob.slice(contentRange.low, contentRange.high + 1);
                yield _awaitAsyncGenerator(retry( /*#__PURE__*/_asyncToGenerator(function* () {
                  const body = _this.requestGenerator.createPartHttpBody({
                    transferPart,
                    partData: blob,
                    contentRange
                  });
                  const requestOptions = _objectSpread({
                    body,
                    timeout: _this.options && _this.options.timeout,
                    headers: Object.assign(_this.requestGenerator.createPartHttpHeaders({
                      transferPart,
                      httpBody: body,
                      contentRange
                    }), transferPart.targetHeaders)
                  }, _this.options.requestOptions);
                  // to stay backwards compatible, AEMmultiPart upload supports methods `POST` instead of `PUT`
                  if (_this.options && _this.options.method) {
                    requestOptions.method = _this.options.method;
                  }
                  yield issuePut(targetUrl, requestOptions);
                }), _this.options));
              } else if (targetUrl && isFileProtocol(targetUrl) && transferPart.source.url) {
                console.log("Target has protocol 'file'");
                yield _awaitAsyncGenerator(retry( /*#__PURE__*/_asyncToGenerator(function* () {
                  const totalSize = transferPart.metadata.contentLength;
                  const response = yield streamGet(transferPart.source.url, _objectSpread({
                    headers: Object.assign({
                      [HTTP.HEADER.RANGE]: `${HTTP.RANGE.BYTES}=${contentRange.low}-${contentRange.high}`
                    }, transferPart.sourceHeaders)
                  }, _this.options.requestOptions));
                  const contentLengthStr = response.headers.get(HTTP.HEADER.CONTENT_LENGTH);
                  const contentLength = Number.parseInt(contentLengthStr, 10);
                  if (!Number.isFinite(contentLength)) {
                    throw Error(`Server did not respond with a Content-Length header: ${contentLengthStr}`);
                  }

                  // there have been cases where the server does not honor the range header.
                  // since we'll be reading the entire response into memory, protect against accidentally
                  // reading a very large amount of data into memory. For example, if the server responds with
                  // an entire 1GB file even though we only requested a portion of that file, avoid reading
                  // the whole 1GB into memory.
                  if (contentLength !== contentRange.length) {
                    throw Error(`Server does not seem to have respected Range header. Expected range ${contentRange.low}-${contentRange.high}, content length is ${contentLength}B`);
                  }
                  console.log("Converting stream to buffer to get response data");
                  const buffer = yield streamToBuffer(HTTP.METHOD.GET, transferPart.source.url, response.status, response.body, contentLength);
                  yield _this.randomFileAccess.write(targetUrl, contentRange, buffer, totalSize);
                }), _this.options));
              }
              controller.notify(TransferEvents.AFTER_TRANSFER, _this.name, transferPart);
              yield transferPart;
            } catch (error) {
              const stringifiedError = JSON.stringify(error);
              if (stringifiedError !== "{}") {
                logger.error(`Error during transfer: ${stringifiedError}`);
              } else {
                logger.error(`Error during transfer: ${error}`);
              }
              controller.notifyError(_this.name, error, transferPart);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion && _iterator.return != null) {
            yield _awaitAsyncGenerator(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    })();
  }
}
module.exports = {
  Transfer
};