/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
const logger = require("../logger");
const {
  AssetMetadata
} = require("../asset/assetmetadata");
const {
  AssetVersion
} = require("../asset/assetversion");
const {
  AsyncGeneratorFunction
} = require("../generator/function");
const {
  getContentType,
  getETag,
  getFilename,
  getHeaders,
  getLastModified,
  getSize
} = require("../headers");
const {
  isFileProtocol,
  getFileStats
} = require("../util");
const {
  retry
} = require("../retry");
const mime = require("mime-types");
const {
  TransferEvents
} = require("../controller/transfercontroller");

/**
 * @typedef {Object} GetAssetMetadataOptions
 * @property {Number} [timeout=30000] Socket timeout
 * @property {Number} [retryMaxCount] number of retry attempts, overrides retryMaxDuration
 * @property {Number} [retryMaxDuration=60000] time to retry until throwing an error (ms)
 * @property {Number} [retryInterval=100] time between retries, used by exponential backoff (ms)
 * @property {Boolean} [retryEnabled=true] retry on failure enabled
 * @property {Boolean} [retryAllErrors=false] whether or not to retry on all http error codes or just >=500
 * @property {Object} requestOptions Options that will be passed to fetch (either node-fetch-npm or native fetch, depending on the context)
 */
/**
 * Retrieve asset metadata information from the sources for the transfer asset. 
 * Results in updated transfer assets.
 * 
 * Supports Blob/File, file:// and http/https sources
 */
class GetAssetMetadata extends AsyncGeneratorFunction {
  /**
   * Construct the GetAssetMetadata function.
   * 
   * @param {GetAssetMetadataOptions} [options] Options to request asset metadata
   */
  constructor(options) {
    super();
    this.options = options;
  }

  /**
   * Initiates the upload of the given assets
   * 
   * @generator
   * @param {TransferAsset[]|Generator||AsyncGenerator} transferAssets Transfer assets with a target of AEMAsset  
   * @param {TransferController} controller Transfer controller
   * @yields {TransferAsset} Transfer asset with a target of AEMMultipartAsset
   */
  execute(transferAssets, controller) {
    var _this = this;
    return _wrapAsyncGenerator(function* () {
      var _iteratorAbruptCompletion = false;
      var _didIteratorError = false;
      var _iteratorError;
      try {
        for (var _iterator = _asyncIterator(transferAssets), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
          const transferAsset = _step.value;
          {
            try {
              controller.notify(TransferEvents.GET_ASSET_METADATA, _this.name, transferAsset);
              const source = transferAsset.source;
              if (source.blob) {
                transferAsset.acceptRanges = true;
                transferAsset.metadata = new AssetMetadata(source.blob.name, source.blob.type, source.blob.size);
                transferAsset.version = new AssetVersion(source.blob.lastModified);
              } else if (isFileProtocol(source.url)) {
                const {
                  size,
                  mtimeMs
                } = yield _awaitAsyncGenerator(getFileStats(source.url));
                const lastModified = Math.round(mtimeMs); // fractional number
                const contentType = mime.lookup(source.url.pathname) || "";
                transferAsset.acceptRanges = true;
                transferAsset.metadata = new AssetMetadata(source.url.pathname, contentType, size);
                transferAsset.version = new AssetVersion(lastModified);
              } else {
                if (transferAsset.metadata && transferAsset.metadata.filename && transferAsset.metadata.contentType && transferAsset.metadata.contentLength) {
                  console.log(`Transfer asset has all needed metadata to proceed (content-type: ${transferAsset.metadata.contentType}, content length: ${transferAsset.metadata.contentLength})`);
                } else {
                  console.log("Transfer asset needs to acquire additional metadata. Executing metadata request");
                  yield _awaitAsyncGenerator(retry( /*#__PURE__*/function () {
                    var _ref = _asyncToGenerator(function* (options) {
                      // S3 doesn't support HEAD requests against presigned URLs
                      // TODO: 0-byte file support for S3 which results in a 416 error
                      const headers = yield getHeaders(source.url, {
                        timeout: options && options.timeout,
                        headers: source.headers,
                        doGet: source.url.host.includes(".amazonaws.com"),
                        requestOptions: options && options.requestOptions
                      });
                      transferAsset.acceptRanges = headers.get("accept-ranges") === "bytes";
                      console.log(`Server accepts ranges: ${transferAsset.acceptRanges} (accept-ranges header set to bytes)`);
                      transferAsset.metadata = new AssetMetadata(getFilename(headers), getContentType(headers), getSize(headers));
                      transferAsset.version = new AssetVersion(getLastModified(headers), getETag(headers));
                    });
                    return function (_x) {
                      return _ref.apply(this, arguments);
                    };
                  }(), _this.options));
                }
              }
              controller.notify(TransferEvents.AFTER_GET_ASSET_METADATA, _this.name, transferAsset);
              yield transferAsset;
            } catch (error) {
              logger.error(`Error while retrieving metadata: ${JSON.stringify(error) || error}`);
              controller.notifyError(_this.name, error, transferAsset);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion && _iterator.return != null) {
            yield _awaitAsyncGenerator(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    })();
  }
}
module.exports = {
  GetAssetMetadata
};