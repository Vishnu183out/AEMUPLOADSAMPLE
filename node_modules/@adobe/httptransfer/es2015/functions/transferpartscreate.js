/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen.return && (this.return = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
const logger = require("../logger");
const {
  AsyncGeneratorFunction
} = require("../generator/function");
const {
  TransferPart
} = require("../asset/transferpart");
const {
  calculatePartSize,
  generatePartRanges
} = require("../aempartsize");
const {
  isFileProtocol
} = require("../util");
const DRange = require("drange");
const {
  TransferEvents
} = require("../controller/transfercontroller");
const DEFAULT_FILE_TARGET_PART_SIZE = 10485760;

/**
 * @typedef {Object} CreateTransferPartsOptions
 * @property {Number} [preferredPartSize] Preferred part size, defaults to 10MB when the target is a file:// url
 */
/**
 * Split TransferAsset to TransferParts
 * 
 * Supports:
 * 
 * - Multi-part targets where the transfer asset has multipartTarget
 * - File targets which allow random-access writes
 * 
 * If the source does not support range requests, or the target is not a multi-part target or file it
 * will default in a single part transfer.
 */
class CreateTransferParts extends AsyncGeneratorFunction {
  /**
   * Construct the CreateTransferParts function.
   * 
   * @param {CreateTransferPartsOptions} [options] Options to split source parts
   */
  constructor(options) {
    super();
    this.preferredPartSize = options && options.preferredPartSize;
  }

  /**
   * Split TransferAsset to TransferParts using a fixed size part size.
   * 
   * notifyBefore -> the transfer assets as received
   * notifyAfter  -> each transfer part before yielded
   * notifyYield  -> each transfer part after yielded
   * 
   * @generator
   * @param {TransferAsset[]|Generator||AsyncGenerator} transferAssets Transfer assets, target going to AEM
   * @param {TransferController} controller Transfer controller
   * @yields {TransferPart} Transfer part
   */
  execute(transferAssets, controller) {
    var _this = this;
    return _wrapAsyncGenerator(function* () {
      var _iteratorAbruptCompletion = false;
      var _didIteratorError = false;
      var _iteratorError;
      try {
        for (var _iterator = _asyncIterator(transferAssets), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
          const transferAsset = _step.value;
          {
            try {
              controller.notify(TransferEvents.CREATE_TRANSFER_PARTS, _this.name, transferAsset);
              console.log(`Server accepts ranges for this transfer asset: ${transferAsset.acceptRanges}`);
              const contentLength = transferAsset.metadata.contentLength;
              if (transferAsset.acceptRanges && transferAsset.multipartTarget) {
                const {
                  targetUrls,
                  minPartSize,
                  maxPartSize,
                  headers: targetHeaders
                } = transferAsset.multipartTarget;
                const partSize = calculatePartSize(targetUrls.length, contentLength, minPartSize, maxPartSize, _this.preferredPartSize);
                let idx = 0;
                for (const range of generatePartRanges(contentLength, partSize)) {
                  const transferPart = new TransferPart(transferAsset, [targetUrls[idx]], range, targetHeaders);
                  controller.notify(TransferEvents.AFTER_CREATE_TRANSFER_PARTS, _this.name, transferPart);
                  yield transferPart;
                  ++idx;
                }
                console.log(`${idx} transfer parts created (multipart target)`);
              } else if (transferAsset.acceptRanges && isFileProtocol(transferAsset.target.url)) {
                const targetUrls = [transferAsset.target.url];
                const partSize = _this.preferredPartSize || DEFAULT_FILE_TARGET_PART_SIZE;
                let idx = 0;
                for (const range of generatePartRanges(contentLength, partSize)) {
                  const transferPart = new TransferPart(transferAsset, targetUrls, range, transferAsset.target.headers);
                  controller.notify(TransferEvents.AFTER_CREATE_TRANSFER_PARTS, _this.name, transferPart);
                  yield transferPart;
                  ++idx;
                }
                console.log(`${idx} transfer parts created (target uses file protocol)`);
              } else {
                const targetUrls = [transferAsset.target.url];
                const contentRange = new DRange(0, contentLength - 1);
                const transferPart = new TransferPart(transferAsset, targetUrls, contentRange, transferAsset.target.headers);
                controller.notify(TransferEvents.AFTER_CREATE_TRANSFER_PARTS, _this.name, transferAsset);
                yield transferPart;
              }
            } catch (error) {
              logger.error(`Error during transfer parts creation: ${JSON.stringify(error)}`);
              controller.notifyError(_this.name, error, transferAsset);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (_iteratorAbruptCompletion && _iterator.return != null) {
            yield _awaitAsyncGenerator(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    })();
  }
}
module.exports = {
  CreateTransferParts
};