/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const logger = require("./logger");
const {
  issueHead
} = require("./fetch");
const {
  retry
} = require("./retry");
const {
  HTTP,
  MIMETYPE
} = require("./constants");
const {
  parse: parseContentRange
} = require("content-range");
const {
  parse: parseContentType
} = require("content-type");
const {
  parse: parseContentDisposition
} = require("content-disposition");
const DEFAULT_MS_HEADERS_SOCKET_TIMEOUT = process.env.DEFAULT_MS_SOCKET_TIMEOUT || 60000; // socket timeout
function getHeaders(_x) {
  return _getHeaders.apply(this, arguments);
}
/**
 * Last modified header in milliseconds since epoch
 * 
 * @param {Headers} headers HTTP headers
 * @returns {number} Last-modified time stamp in milliseconds since epoch
 */
function _getHeaders() {
  _getHeaders = _asyncToGenerator(function* (url, options = {}) {
    const timeoutValue = options.timeout || DEFAULT_MS_HEADERS_SOCKET_TIMEOUT;
    const {
      requestOptions = {}
    } = options;
    const fetchOptions = _objectSpread({
      timeout: timeoutValue,
      headers: _objectSpread({}, options.headers)
    }, requestOptions);
    if (options.doGet) {
      fetchOptions.method = HTTP.METHOD.GET;
      fetchOptions.headers.range = "bytes=0-0";
    }
    const response = yield issueHead(url, fetchOptions);
    return response.headers;
  });
  return _getHeaders.apply(this, arguments);
}
function getLastModified(headers) {
  const lastModified = Date.parse(headers.get(HTTP.HEADER.LAST_MODIFIED));
  if (Number.isFinite(lastModified)) {
    return lastModified;
  } else {
    return undefined;
  }
}

/**
 * Non-weak ETag identifier
 * 
 * @param {Headers} headers HTTP headers
 * @returns {string} Non-weak ETag identifier
 */
function getETag(headers) {
  const etag = headers.get(HTTP.HEADER.ETAG);
  if (etag && !etag.startsWith("W/")) {
    return etag;
  } else {
    return undefined;
  }
}

/**
 * @typedef {Object} ContentDisposition
 * @property {'attachment'|'inline'|string} type Type
 * @property {*} parameters Parameters
 */
/**
 * Parsed content-disposition header
 * 
 * @param {Headers} headers HTTP headers
 * @returns {ContentDisposition} Parsed content-disposition header
 */
function getContentDisposition(headers) {
  const value = headers.get(HTTP.HEADER.CONTENT_DISPOSITION);
  if (value) {
    try {
      const parsed = parseContentDisposition(value, {
        fallback: false
      });
      return parsed;
    } catch (e) {
      logger.warn(`Unable to parse 'content-disposition' header: ${value}`, e.message || e);
    }
  }
  return undefined;
}

/**
 * Filename from the content-disposition header
 * 
 * @param {Headers} headers HTTP headers
 * @returns {string} Filename from the content-disposition header
 */
function getFilename(headers) {
  const value = getContentDisposition(headers);
  return value && value.parameters && value.parameters.filename;
}

/**
 * @typedef {Object} ContentType
 * @property {string} type Mimetype
 * @property {*} parameters Parameters
 */
/**
 * Parsed content-type header
 * 
 * @param {Headers} headers HTTP headers
 * @returns {ContentType} Parsed content-type header
 */
function getContentType(headers) {
  const value = headers.get(HTTP.HEADER.CONTENT_TYPE);
  if (value) {
    try {
      return parseContentType(value);
    } catch (e) {
      logger.warn(`Unable to parse 'content-type' header: ${value}`, e.message || e);
    }
  }
  return undefined;
}

/**
 * Mime-type
 * 
 * @param {Headers} headers HTTP headers
 * @returns {string} Mime-type
 */
function getMimetype(headers) {
  const value = getContentType(headers);
  return value && value.type;
}

/**
 * @typedef {Object} ContentRange
 * @property {String} unit Units (bytes)
 * @property {Number} [start] Starting offset
 * @property {Number} [end] Ending offset (inclusive)
 * @property {Number} [size] Total size of the content
 */
/**
 * Retrieve and parse Content-Range from the HTTP headers
 * 
 * @param {Headers} headers HTTP headers
 * @returns {ContentRange} Content range
 */
function getContentRange(headers) {
  const contentRange = headers.get(HTTP.HEADER.CONTENT_RANGE);
  if (contentRange) {
    return parseContentRange(contentRange);
  } else {
    return undefined;
  }
}

/**
 * Retrieve and parse Content-Length from the HTTP headers
 * 
 * @param {Headers} headers HTTP headers
 * @returns {number} Content length or undefined
 */
function getContentLength(headers) {
  const value = headers.get(HTTP.HEADER.CONTENT_LENGTH);
  if (value) {
    const parsed = parseInt(value);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  return undefined;
}

/**
 * Retrieve the content length from the Content-Range or Content-Length header
 * 
 * @param {Headers} headers HTTP headers
 * @returns Content length from the Content-Range or Content-Length header
 */
function getSize(headers) {
  const contentRange = getContentRange(headers);
  const contentLength = getContentLength(headers);
  return contentRange && contentRange.size || contentLength;
}

/**
 * @typedef {Object} ResourceHeaders
 *
 * @property {String} filename Resource filename (if available)
 * @property {String} mimetype Resource mimetype (if available)
 * @property {Number} size Resource size in bytes (if available)
 */
/**
 * Parse headers
 *
 * @param {Headers} headers Headers returned by fetch (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
 * @returns {ResourceHeaders} parsed resource headers
 */
function parseResourceHeaders(headers) {
  const result = {
    mimetype: getMimetype(headers) || MIMETYPE.APPLICATION_OCTET_STREAM,
    size: getSize(headers) || 0
  };
  const filename = getFilename(headers);
  if (filename) {
    result.filename = filename;
  }
  return result;
}

/**
 * @typedef {Object} GetResourceHeadersOptions
 * @property {Object} headers An object containing request headers
 * @property {Number} timeout Socket timeout
 * @property {Boolean} doGet Use the HTTP GET method to fetch response headers
 * @property {Number} [retryMax=60000] time to retry until throwing an error (ms)
 * @property {Number} [retryInterval=100] time between retries, used by exponential backoff (ms)
 * @property {Boolean} [retryEnabled=true] retry on failure enabled
 * @property {Boolean} [retryAllErrors=false] whether or not to retry on all http error codes or just >=500
 * @property {Object} requestOptions Options that will be passed to fetch (either node-fetch-npm or native fetch, depending on the context)
 */
/**
 * Retrieve content information
 *
 * @param {String} url URL to request content headers for
 * @param {GetResourceHeadersOptions} options Resource header options
 * @returns {ResourceHeaders} content headers
 */
function getResourceHeaders(_x2, _x3) {
  return _getResourceHeaders.apply(this, arguments);
}
function _getResourceHeaders() {
  _getResourceHeaders = _asyncToGenerator(function* (url, options) {
    return retry( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (options) {
        const headers = yield getHeaders(url, options);
        return parseResourceHeaders(headers);
      });
      return function (_x4) {
        return _ref.apply(this, arguments);
      };
    }(), options);
  });
  return _getResourceHeaders.apply(this, arguments);
}
module.exports = {
  getHeaders,
  parseResourceHeaders,
  getResourceHeaders,
  getContentRange,
  getContentLength,
  getContentType,
  getETag,
  getFilename,
  getLastModified,
  getSize
};