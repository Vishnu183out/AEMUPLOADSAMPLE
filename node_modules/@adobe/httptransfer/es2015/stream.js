/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const fetch = require('./fetch');
const {
  retry
} = require("./retry");
const {
  parseResourceHeaders
} = require('./headers');
const {
  HttpStreamError
} = require('./error');
const {
  HTTP,
  MIMETYPE
} = require("./constants");

/**
 * @typedef {Object} DownloadStreamOptions
 *
 * @property {Number} timeout Socket timeout
 * @property {Object} headers An object containing request headers
 */
/**
 * Download content from a URL and write it to a stream
 *
 * @param {String|URL} url Source URL
 * @param {Object} writeStream Target writable stream
 *
 * @param {DownloadStreamOptions} options Download options
 * @returns {Promise} resolves to the number of bytes downloaded
 */
function downloadStream(_x, _x2) {
  return _downloadStream.apply(this, arguments);
}
/**
 * @typedef {Object} UploadStreamOptions
 *
 * @property {String} method HTTP method (defaults to 'PUT')
 * @property {Number} timeout Socket timeout
 * @property {Object} headers An object containing request headers
 */
/**
 * Upload a stream of data to a URL
 *
 * @param {Object} readStream Source readable stream
 * @param {String} url Target URL
 * @param {UploadStreamOptions} options Upload options
 * @returns {Promise} resolves when upload completes
 */
function _downloadStream() {
  _downloadStream = _asyncToGenerator(function* (url, writeStream, options = {}) {
    const response = yield fetch.streamGet(url, Object.assign(options, {
      // since we must check the bytes recieved ourselves to check for truncated data
      // (see lines 60-67 below),
      // we disable encoding since we cannot access the raw response body 
      // to check the byte length and compare it with the `Content-Range` header
      // we plan to remove this and allow encoding when we switch to node-fetch v3
      compress: false
    }));
    const expectedBytes = parseResourceHeaders(response.headers).size;
    let actualBytes = 0;
    return new Promise((resolve, reject) => {
      response.body.on("data", chunk => {
        actualBytes += chunk.length;
      }).on("error", err => {
        reject(new HttpStreamError("GET", url, response.status, err.message));
      }).pipe(writeStream).on("error", err => {
        reject(new HttpStreamError("GET", url, response.status, err.message));
      }).on("finish", () => {
        // for now, we manually check bytes length since there is no stream error event handling in `node-fetch-npm`
        // there is already a fix in node-fetch v3: https://github.com/node-fetch/node-fetch/blob/master/src/index.js#L226-L230
        // the fix comes from this issue: https://github.com/node-fetch/node-fetch/issues/309
        // we plan to switch to node-fetch when v3 release is stable
        if (expectedBytes && actualBytes !== expectedBytes) {
          reject(new HttpStreamError("GET", url, response.status, `Unexpected stream-size. Received ${actualBytes} bytes, expected ${expectedBytes} bytes`));
        }
        resolve(actualBytes);
      });
    });
  });
  return _downloadStream.apply(this, arguments);
}
function uploadStream(_x3, _x4, _x5) {
  return _uploadStream.apply(this, arguments);
}
/**
 * @typedef {Object} TransferStreamOptions
 *
 * @property {DownloadStreamOptions} source Source options
 * @property {UploadStreamOptions} target Target options
 * @property {Number} [retryMax=60000] time to retry until throwing an error (ms)
 * @property {Number} [retryInterval=100] time between retries, used by exponential backoff (ms)
 * @property {Boolean} [retryEnabled=true] retry on failure enabled
 * @property {Boolean} [retryAllErrors=false] whether or not to retry on all http error codes or just >=500
 */
/**
 * Transfer a stream of content from one url to another
 *
 * @param {String} sourceUrl Source URL
 * @param {String} targetUrl Target URL
 * @param {TransferStreamOptions} options Transfer options
 * @returns {Promise} resolves when transfer completes
 */
function _uploadStream() {
  _uploadStream = _asyncToGenerator(function* (readStream, url, options) {
    return fetch.issuePut(url, _objectSpread({
      body: readStream
    }, options));
  });
  return _uploadStream.apply(this, arguments);
}
function transferStream(_x6, _x7) {
  return _transferStream.apply(this, arguments);
}
function _transferStream() {
  _transferStream = _asyncToGenerator(function* (sourceUrl, targetUrl, options = {}) {
    return retry( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (options) {
        const response = yield fetch.streamGet(sourceUrl, options.source);

        // resolve headers, allow override by options
        const resourceHeaders = parseResourceHeaders(response.headers);
        const contentType = response.headers.get(HTTP.HEADER.CONTENT_TYPE) || MIMETYPE.APPLICATION_OCTET_STREAM;
        const headers = _objectSpread({
          [HTTP.HEADER.CONTENT_LENGTH]: resourceHeaders.size,
          [HTTP.HEADER.CONTENT_TYPE]: contentType
        }, options.target && options.target.headers);

        // resolve options, headers last since they are already resolved
        const targetOptions = _objectSpread(_objectSpread({}, options.target), {}, {
          headers
        });
        return uploadStream(response.body, targetUrl, targetOptions);
      });
      return function (_x8) {
        return _ref.apply(this, arguments);
      };
    }(), options);
  });
  return _transferStream.apply(this, arguments);
}
module.exports = {
  downloadStream,
  uploadStream,
  transferStream
};